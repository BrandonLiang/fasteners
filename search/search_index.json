{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fasteners","text":"<p>Python standard library provides an Exclusive Lock for threads and Exclusive Lock for processes spawned by <code>multiprocessing</code> module. <code>fasteners</code> provides additional three synchronization primitives:</p> <ul> <li>Exclusive Lock for independent processes</li> <li>Readers Writer Lock for independent processes</li> <li>Readers Writer Lock for threads</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fasteners\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See User Guide for usage tips and examples and Reference for detailed API.</p>"},{"location":"#similar-libraries","title":"Similar libraries","text":"<p><code>portarlocker</code>: readers writer lock and semaphore for  independent processes, exclusive lock based on redis. </p> <p><code>py-filelock</code>: exclusive lock for independent processes.</p> <p><code>pyReaderWriterLock</code>: inter-thread readers writer  locks, optionally downgradable, with various priorities (reader, writer, fair).</p>"},{"location":"CHANGELOG/","title":"ChangeLog","text":"<p>The format is based on Keep a Changelog</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#018","title":"[0.18]","text":"<ul> <li>Reshuffle the process lock code and properly document it.</li> <li>Revamp the docs and switch from sphinx to mkdocs</li> <li>Remove difficult to use tread lock features from docs</li> <li>Bring back support for eventlet <code>spawn_n</code></li> <li>Remove support for python3.6. It should still work, but is no longer tested.</li> </ul>"},{"location":"CHANGELOG/#0173","title":"[0.17.3]:","text":"<ul> <li>Allow writer to become a reader in thread ReaderWriter lock</li> </ul>"},{"location":"CHANGELOG/#0172","title":"[0.17.2]:","text":"<ul> <li>Remove unnecessary setuptools pin</li> </ul>"},{"location":"CHANGELOG/#0171","title":"[0.17.1]:","text":"<ul> <li>Switch to the modern python package build infrastructure</li> </ul>"},{"location":"CHANGELOG/#017-never-released","title":"[0.17]: [NEVER RELEASED]","text":"<ul> <li>Remove support for python 3.5 and earlier, including 2.7</li> <li>Add support for python 3.9 and 3.10</li> <li>Fix a conflict with django lock</li> <li>Add <code>__version__</code> and <code>__all__</code> attributes</li> <li>Fix a failure to parse README as utf-8</li> <li>Move from nosetest to pytest and cleanup testing infrastructure</li> </ul>"},{"location":"CHANGELOG/#0163","title":"[0.16.3]:","text":"<ul> <li>Fix a failure to parse README as utf-8 on python2</li> </ul>"},{"location":"CHANGELOG/#0162","title":"[0.16.2]:","text":"<ul> <li>Fix a failure to parse README as utf-8</li> </ul>"},{"location":"CHANGELOG/#0161-yanked","title":"[0.16.1]: [YANKED]","text":""},{"location":"CHANGELOG/#016","title":"[0.16]:","text":"<ul> <li>Move from travis and appveyor to github actions</li> <li>Add interprocess reader writer lock</li> <li>Improve README</li> <li>remove unused eventlet import</li> <li>use stdlib monotonic instead of external for python &gt;= 3.4</li> </ul>"},{"location":"CHANGELOG/#015","title":"[0.15]:","text":"<ul> <li>Add testing for additional python versions</li> <li>Remove python 2.6 support</li> <li>Remove eventlet dependency and use     threading.current_thread instead</li> </ul>"},{"location":"CHANGELOG/#014","title":"[0.14]:","text":"<ul> <li>Allow providing a custom exception logger to 'locked' decorator</li> <li>Allow providing a custom logger to process lock class</li> <li>Fix issue #12</li> </ul>"},{"location":"CHANGELOG/#013","title":"[0.13]:","text":"<ul> <li>Fix 'ensure_tree' check on freebsd</li> </ul>"},{"location":"CHANGELOG/#012","title":"[0.12]:","text":"<ul> <li>Use a tiny retry util helper class for performing process locking retries.</li> </ul>"},{"location":"CHANGELOG/#011","title":"[0.11]:","text":"<ul> <li>Directly use monotonic.monotonic.</li> <li>Use BLATHER level for previously INFO/DEBUG statements.</li> </ul>"},{"location":"CHANGELOG/#010","title":"[0.10]:","text":"<ul> <li>Add LICENSE in generated source tarballs</li> <li>Add a version.py file that can be used to extract the current version.</li> </ul>"},{"location":"CHANGELOG/#09","title":"[0.9]:","text":"<ul> <li>Allow providing a non-standard (eventlet or other condition class) to the      r/w lock for cases where it is useful to do so.</li> <li>Instead of having the r/w lock take a find eventlet keyword argument, allow      for it to be provided a function that will be later called to get the      current thread. This allows for the current hack to be easily removed     by users (if they so desire).</li> </ul>"},{"location":"CHANGELOG/#08","title":"[0.8]:","text":"<ul> <li>Add fastener logo (from openclipart).</li> <li>Ensure r/w writer -&gt; reader -&gt; writer lock acquisition.</li> <li>Attempt to use the monotonic pypi module if its installed for monotonically      increasing time on python versions where this is not built-in.</li> </ul>"},{"location":"CHANGELOG/#07","title":"[0.7]:","text":"<ul> <li>Add helpful <code>locked</code> decorator that can lock a method using a found      attribute (a lock object or list of lock objects) in the instance the method      is attached to.</li> <li>Expose top level <code>try_lock</code> function.</li> </ul>"},{"location":"CHANGELOG/#06","title":"[0.6]:","text":"<ul> <li>Allow the sleep function to be provided (so that various alternatives other      than time.sleep can be used), ie eventlet.sleep (or other).</li> <li>Remove dependency on oslo.utils (replace with small utility code that      achieves the same effect).</li> </ul>"},{"location":"CHANGELOG/#05","title":"[0.5]:","text":"<ul> <li>Make it possible to provide an acquisition timeout to the interprocess lock      (which when acquisition can not complete in the desired time will return     false).</li> </ul>"},{"location":"CHANGELOG/#04","title":"[0.4]:","text":"<ul> <li>Have the interprocess lock acquire take a blocking keyword argument      (defaulting to true) that can avoid blocking trying to acquire the lock</li> </ul>"},{"location":"CHANGELOG/#03","title":"[0.3]:","text":"<ul> <li>Renamed from 'shared_lock' to 'fasteners'</li> </ul>"},{"location":"CHANGELOG/#021","title":"[0.2.1]","text":"<ul> <li>Fix delay not working as expected</li> </ul>"},{"location":"CHANGELOG/#02","title":"[0.2]:","text":"<ul> <li>Add a interprocess lock</li> </ul>"},{"location":"CHANGELOG/#01","title":"[0.1]:","text":"<ul> <li>Add travis yaml file</li> <li>Initial commit/import</li> </ul>"},{"location":"api/inter_process/","title":"Process Lock API","text":""},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock","title":"<code>InterProcessLock</code>","text":"<p>An interprocess lock.</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock-functions","title":"Functions","text":""},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.__init__","title":"<code>__init__(path, sleep_func=time.sleep, logger=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file that will be used for locking.</p> required <code>sleep_func</code> <code>Callable[[float], None]</code> <p>Optional function to use for sleeping.</p> <code>sleep</code> <code>logger</code> <code>Optional[logging.Logger]</code> <p>Optional logger to use for logging.</p> <code>None</code>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.acquire","title":"<code>acquire(blocking=True, delay=0.01, max_delay=0.1, timeout=None)</code>","text":"<p>Attempt to acquire the lock.</p> <p>Parameters:</p> Name Type Description Default <code>blocking</code> <code>bool</code> <p>Whether to wait to try to acquire the lock.</p> <code>True</code> <code>delay</code> <code>float</code> <p>When <code>blocking</code>, starting delay as well as the delay increment (in seconds).</p> <code>0.01</code> <code>max_delay</code> <code>float</code> <p>When <code>blocking</code> the maximum delay in between attempts to acquire (in seconds).</p> <code>0.1</code> <code>timeout</code> <code>Optional[float]</code> <p>When <code>blocking</code>, maximal waiting time (in seconds).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not the acquisition succeeded</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.release","title":"<code>release()</code>","text":"<p>Release the previously acquired lock.</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock","title":"<code>InterProcessReaderWriterLock</code>","text":"<p>An interprocess readers writer lock.</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock-functions","title":"Functions","text":""},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.__init__","title":"<code>__init__(path, sleep_func=time.sleep, logger=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file that will be used for locking.</p> required <code>sleep_func</code> <code>Callable[[float], None]</code> <p>Optional function to use for sleeping.</p> <code>sleep</code> <code>logger</code> <code>Optional[logging.Logger]</code> <p>Optional logger to use for logging.</p> <code>None</code>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.read_lock","title":"<code>read_lock(delay=0.01, max_delay=0.1)</code>","text":"<p>Context manager that grans a read lock</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.write_lock","title":"<code>write_lock(delay=0.01, max_delay=0.1)</code>","text":"<p>Context manager that grans a write lock</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.acquire_read_lock","title":"<code>acquire_read_lock(blocking=True, delay=0.01, max_delay=0.1, timeout=None)</code>","text":"<p>Attempt to acquire a reader's lock.</p> <p>Parameters:</p> Name Type Description Default <code>blocking</code> <code>bool</code> <p>Whether to wait to try to acquire the lock.</p> <code>True</code> <code>delay</code> <code>float</code> <p>When <code>blocking</code>, starting delay as well as the delay increment (in seconds).</p> <code>0.01</code> <code>max_delay</code> <code>float</code> <p>When <code>blocking</code> the maximum delay in between attempts to acquire (in seconds).</p> <code>0.1</code> <code>timeout</code> <code>float</code> <p>When <code>blocking</code>, maximal waiting time (in seconds).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not the acquisition succeeded</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.acquire_write_lock","title":"<code>acquire_write_lock(blocking=True, delay=0.01, max_delay=0.1, timeout=None)</code>","text":"<p>Attempt to acquire a writer's lock.</p> <p>Parameters:</p> Name Type Description Default <code>blocking</code> <code>bool</code> <p>Whether to wait to try to acquire the lock.</p> <code>True</code> <code>delay</code> <code>float</code> <p>When <code>blocking</code>, starting delay as well as the delay increment (in seconds).</p> <code>0.01</code> <code>max_delay</code> <code>float</code> <p>When <code>blocking</code> the maximum delay in between attempts to acquire (in seconds).</p> <code>0.1</code> <code>timeout</code> <code>float</code> <p>When <code>blocking</code>, maximal waiting time (in seconds).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not the acquisition succeeded</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.release_write_lock","title":"<code>release_write_lock()</code>","text":"<p>Release the writer's lock.</p>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.release_read_lock","title":"<code>release_read_lock()</code>","text":"<p>Release the reader's lock.</p>"},{"location":"api/inter_process/#decorators","title":"Decorators","text":""},{"location":"api/inter_process/#fasteners.process_lock.interprocess_locked","title":"<code>interprocess_locked(path)</code>","text":"<p>Acquires &amp; releases an interprocess lock around the call to the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file used for locking.</p> required"},{"location":"api/inter_process/#fasteners.process_lock.interprocess_read_locked","title":"<code>interprocess_read_locked(path)</code>","text":"<p>Acquires &amp; releases an interprocess read lock around the call into the decorated function</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file used for locking.</p> required"},{"location":"api/inter_process/#fasteners.process_lock.interprocess_write_locked","title":"<code>interprocess_write_locked(path)</code>","text":"<p>Acquires &amp; releases an interprocess  write lock around the call into the decorated function</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file used for locking.</p> required"},{"location":"api/inter_thread/","title":"Thread lock API","text":""},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock","title":"<code>ReaderWriterLock</code>","text":"<p>             Bases: <code>object</code></p> <p>An inter-thread readers writer lock.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock-attributes","title":"Attributes","text":""},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.has_pending_writers","title":"<code>has_pending_writers: bool</code>  <code>property</code>","text":"<p>Check if there pending writers</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether there are pending writers.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.owner","title":"<code>owner: Optional[str]</code>  <code>property</code>","text":"<p>Caller ownership (if any) of the lock</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p><code>'w'</code> if caller is a writer, <code>'r'</code> if caller is a reader, None otherwise.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock-functions","title":"Functions","text":""},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.__init__","title":"<code>__init__(condition_cls=threading.Condition, current_thread_functor=threading.current_thread)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>condition_cls</code> <p>Optional custom <code>Condition</code> primitive used for synchronization.</p> <code>Condition</code> <code>current_thread_functor</code> <p>Optional function that returns the identity of the thread in case threads are not properly identified by threading.current_thread</p> <code>current_thread</code>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.is_writer","title":"<code>is_writer(check_pending=True)</code>","text":"<p>Check if caller is a writer (optionally pending writer).</p> <p>Parameters:</p> Name Type Description Default <code>check_pending</code> <code>bool</code> <p>Whether to check for pending writer status.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the caller is the active (or optionally pending) writer.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.is_reader","title":"<code>is_reader()</code>","text":"<p>Check if caller is a reader.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the caller is an active reader.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.read_lock","title":"<code>read_lock()</code>","text":"<p>Context manager that grants a read lock.</p> <p>Will wait until no active or pending writers.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a pending writer tries to acquire a read lock.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.write_lock","title":"<code>write_lock()</code>","text":"<p>Context manager that grants a write lock.</p> <p>Will wait until no active readers. Blocks readers after acquiring.</p> <p>Guaranteed for locks to be processed in fair order (FIFO).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an active reader attempts to acquire a lock.</p>"},{"location":"guide/","title":"User Guide","text":""},{"location":"guide/#basic-exclusive-lock-usage","title":"Basic Exclusive Lock Usage","text":"<p>Exclusive Lock for independent processes has the same API as the threading.Lock for threads: <pre><code>import fasteners\nimport threading\nlock = threading.Lock()                                 # for threads\nlock = fasteners.InterProcessLock('path/to/lock.file')  # for processes\nwith lock:\n... # exclusive access\n# or alternatively    \nlock.acquire()\n... # exclusive access\nlock.release()\n</code></pre></p>"},{"location":"guide/#basic-reader-writer-lock-usage","title":"Basic Reader Writer lock usage","text":"<p>Reader Writer lock has a similar API, which is the same for threads or processes:</p> <pre><code>import fasteners\n# for threads\nrw_lock = fasteners.ReaderWriterLock()                                 \n# for processes\nrw_lock = fasteners.InterProcessReaderWriterLock('path/to/lock.file')  \nwith rw_lock.write_lock():\n... # write access\nwith rw_lock.read_lock():\n... # read access\n# or alternatively, for processes only:\nrw_lock.acquire_read_lock()\n... # read access\nrw_lock.release_read_lock()\nrw_lock.acquire_write_lock()\n... # write access\nrw_lock.release_write_lock()\n</code></pre>"},{"location":"guide/#advanced-usage","title":"Advanced usage","text":"<p>For more details and options see Process lock details and Thread lock details.</p>"},{"location":"guide/glossary/","title":"Glossary","text":"<p>To learn more about the various aspects of locks, check the wikipedia pages for locks and readers writer locks  Here we briefly mention the main notions used in the documentation.</p> <ul> <li>Lock - a mechanism that prevents two or more threads or processes from running the same code at the same time.</li> <li>Readers writer lock - a mechanism that prevents two or more threads from having write (or write and read) access,   while allowing multiple readers.</li> <li> <p>Reentrant lock - a lock that can be acquired (and then released) multiple times, as in:</p> <pre><code>with lock:\nwith lock:\n... # some code\n</code></pre> </li> <li> <p>Mandatory lock (as opposed to advisory lock) - a lock that is enforced by the operating system, rather than   by the cooperation between threads or processes</p> </li> <li>Upgradable readers writer lock - a readers writer lock that can be upgraded from reader to writer (or downgraded   from writer to reader) without losing the lock that is already held, as in: <pre><code>with rw_lock.read_lock():\n... # read access\nwith rw_lock.write_lock():\n... # write access\n... # read access\n</code></pre></li> <li>Readers writer lock preference - describes the behaviour when multiple threads or processes are waiting for   access. Some of the patterns are:<ul> <li>Reader preference - If lock is held by readers, then new readers will get immediate access. This can result   in writers waiting forever (writer starvation).</li> <li>Writer preference - If writer is waiting for a lock, then all the new readers (and writers) will be queued   after it. This can result in readers waiting forever (reader starvation).</li> <li>Phase fair - Lock that alternates between readers and writers.</li> </ul> </li> </ul>"},{"location":"guide/inter_process/","title":"Inter process locks","text":"<p>Fasteners inter-process locks are cross-platform and are released automatically if the process crashes. They are based on the platform specific locking mechanisms:</p> <ul> <li>fcntl for posix (Linux and OSX)</li> <li>LockFileEx (via pywin32) and _locking (via msvcrt) for Windows</li> </ul>"},{"location":"guide/inter_process/#difference-from-multiprocessinglock","title":"Difference from <code>multiprocessing.Lock</code>","text":"<p>Python standard library multiprocessing.Lock functions when the processes are launched by a single main process, who is responsible for managing the  synchronization. <code>fasteners</code> locks use the operating system mechanisms for  synchronization management, and hence work between processes that were launched independently.</p>"},{"location":"guide/inter_process/#timeouts","title":"Timeouts","text":"<p><code>fasteners</code> locks support timeouts, that can be used as follows:</p> <pre><code>import fasteners\nlock = fasteners.InterProcessLock('path/to/lock.file')\nlock.acquire(timeout=10)\n... # exclusive access\nlock.release()\n</code></pre> <p>Equivalently for readers writer lock:</p> <pre><code>import fasteners\nlock = fasteners.InterProcessReaderWriterLock('path/to/lock.file')\nlock.acquire_read_lock(timeout=10)\n... # exclusive access\nlock.release_read_lock()\nlock.acquire_write_lock(timeout=10)\n... # exclusive access\nlock.release_write_lock()\n</code></pre>"},{"location":"guide/inter_process/#decorators","title":"Decorators","text":"<p>For extra sugar, a function that always needs exclusive / read / write access can be decorated using one of the provided decorators. Note that they do not  expose the timeout parameter, and always block until the lock is acquired.</p> <pre><code>import fasteners\n@fasteners.interprocess_read_locked\ndef read_file():\n...\n@fasteners.interprocess_write_locked\ndef write_file():\n...\n@fasteners.interprocess_locked\ndef do_something_exclusive():\n...\n</code></pre>"},{"location":"guide/inter_process/#lack-of-features","title":"(Lack of) Features","text":"<p>The intersection of fcntl and LockFileEx features is quite small, hence you should always assume that:</p> <ul> <li> <p>Locks are advisory. They do not prevent the modification of the locked file   by other processes.</p> </li> <li> <p>Locks can be unintentionally released by simply opening and closing the file   descriptor, so lock files must be accessed only using provided abstractions.</p> </li> <li> <p>Locks are not reentrant. An attempt to acquire a lock multiple times can   result in a deadlock or a crash upon a release of the lock.</p> </li> <li> <p>Reader writer locks are not upgradeable. An attempt to get a reader's lock   while holding a writer's lock (or vice versa) can result in a deadlock or a   crash upon a release of the lock.</p> </li> <li> <p>There are no guarantees regarding usage by multiple threads in a   single process. The locks work only between processes.</p> </li> </ul>"},{"location":"guide/inter_process/#resources","title":"Resources","text":"<p>To learn more about the complications of locking on different platforms we recommend the following resources:</p> <ul> <li> <p>File locking in Linux (blog post)</p> </li> <li> <p>On the Brokenness of File Locking (blog post)</p> </li> <li> <p>Everything you never wanted to know about file locking (blog post)</p> </li> <li> <p>Record Locking (course notes)</p> </li> <li> <p>Windows NT Files -- Locking (pywin32 docs)</p> </li> <li> <p>_locking (Windows Dev Center)</p> </li> <li> <p>LockFileEx function (Windows Dev Center)</p> </li> </ul>"},{"location":"guide/inter_thread/","title":"Inter thread locks","text":"<p>Fasteners inter-thread locks were build specifically for the needs of <code>oslo.concurrency</code> project and thus have a rather peculiar API. We do not recommend using it fully, and it is hence not documented (but maintained until the end of time).</p> <p>Instead, we recommend limiting the use of fasteners inter-thread readers writer lock to the basic API:</p> <pre><code>import fasteners\n# for threads\nrw_lock = fasteners.ReaderWriterLock()\nwith rw_lock.write_lock():\n...  # write access\nwith rw_lock.read_lock():\n...  # read access\n</code></pre>"},{"location":"guide/inter_thread/#lack-of-features","title":"(Lack of) Features","text":"<p>Fasteners inter-thread readers writer lock is</p> <ul> <li> <p>not upgradeable. An attempt to get a reader's lock while holding a writer's   lock (or vice versa) will raise an exception.</p> </li> <li> <p>reentrant (!). You can acquire (and correspondingly release) the lock   multiple times.</p> </li> <li> <p>has writer preference. Readers will queue after writers and pending writers.</p> </li> </ul>"},{"location":"guide/inter_thread/#different-thread-creation-mechanisms","title":"Different thread creation mechanisms","text":"<p>If your threads are created by some other means than the standard library <code>threading</code> module, you may need to provide corresponding thread identification and synchronisation functions to the <code>ReaderWriterLock</code>.</p>"},{"location":"guide/inter_thread/#eventlet","title":"Eventlet","text":"<p>In particular, in case of <code>eventlet</code> threads, you should monkey_patch the stdlib threads with <code>eventlet.monkey_patch(tread=True)</code> and initialise the <code>ReaderWriterLock</code> as <code>ReaderWriterLock(current_thread_functor=eventlet.getcurrent)</code>.</p>"}]}