{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fasteners","text":"<p>Python standard library provides an Exclusive Lock for threads and Exclusive Lock for processes spawned by <code>multiprocessing</code> module. <code>fasteners</code> provides additional three synchronization primitives:</p> <ul> <li>Exclusive Lock for independent processes</li> <li>Readers Writer Lock for independent processes</li> <li>Readers Writer Lock for threads</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fasteners\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See User Guide for usage tips and examples and Reference for detailed API.</p>"},{"location":"#similar-libraries","title":"Similar libraries","text":"<p><code>portarlocker</code>: readers writer lock and semaphore for  independent processes, exclusive lock based on redis. </p> <p><code>py-filelock</code>: exclusive lock for independent processes.</p> <p><code>pyReaderWriterLock</code>: inter-thread readers writer  locks, optionally downgradable, with various priorities (reader, writer, fair).</p>"},{"location":"CHANGELOG/","title":"ChangeLog","text":"<p>The format is based on Keep a Changelog</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":"<ul> <li>Add <code>.acquire_read_lock</code>, <code>.release_read_lock</code>, <code>.acquire_write_lock</code>, and     <code>.release_write_lock</code> methods to the inter thread <code>ReaderWriterLock</code> as was      promised in the README.</li> </ul>"},{"location":"CHANGELOG/#018","title":"[0.18]","text":"<ul> <li>Reshuffle the process lock code and properly document it.</li> <li>Revamp the docs and switch from sphinx to mkdocs</li> <li>Remove difficult to use tread lock features from docs</li> <li>Bring back support for eventlet <code>spawn_n</code></li> <li>Remove support for python3.6. It should still work, but is no longer tested.</li> </ul>"},{"location":"CHANGELOG/#0173","title":"[0.17.3]:","text":"<ul> <li>Allow writer to become a reader in thread ReaderWriter lock</li> </ul>"},{"location":"CHANGELOG/#0172","title":"[0.17.2]:","text":"<ul> <li>Remove unnecessary setuptools pin</li> </ul>"},{"location":"CHANGELOG/#0171","title":"[0.17.1]:","text":"<ul> <li>Switch to the modern python package build infrastructure</li> </ul>"},{"location":"CHANGELOG/#017-never-released","title":"[0.17]: [NEVER RELEASED]","text":"<ul> <li>Remove support for python 3.5 and earlier, including 2.7</li> <li>Add support for python 3.9 and 3.10</li> <li>Fix a conflict with django lock</li> <li>Add <code>__version__</code> and <code>__all__</code> attributes</li> <li>Fix a failure to parse README as utf-8</li> <li>Move from nosetest to pytest and cleanup testing infrastructure</li> </ul>"},{"location":"CHANGELOG/#0163","title":"[0.16.3]:","text":"<ul> <li>Fix a failure to parse README as utf-8 on python2</li> </ul>"},{"location":"CHANGELOG/#0162","title":"[0.16.2]:","text":"<ul> <li>Fix a failure to parse README as utf-8</li> </ul>"},{"location":"CHANGELOG/#0161-yanked","title":"[0.16.1]: [YANKED]","text":""},{"location":"CHANGELOG/#016","title":"[0.16]:","text":"<ul> <li>Move from travis and appveyor to github actions</li> <li>Add interprocess reader writer lock</li> <li>Improve README</li> <li>remove unused eventlet import</li> <li>use stdlib monotonic instead of external for python &gt;= 3.4</li> </ul>"},{"location":"CHANGELOG/#015","title":"[0.15]:","text":"<ul> <li>Add testing for additional python versions</li> <li>Remove python 2.6 support</li> <li>Remove eventlet dependency and use     threading.current_thread instead</li> </ul>"},{"location":"CHANGELOG/#014","title":"[0.14]:","text":"<ul> <li>Allow providing a custom exception logger to 'locked' decorator</li> <li>Allow providing a custom logger to process lock class</li> <li>Fix issue #12</li> </ul>"},{"location":"CHANGELOG/#013","title":"[0.13]:","text":"<ul> <li>Fix 'ensure_tree' check on freebsd</li> </ul>"},{"location":"CHANGELOG/#012","title":"[0.12]:","text":"<ul> <li>Use a tiny retry util helper class for performing process locking retries.</li> </ul>"},{"location":"CHANGELOG/#011","title":"[0.11]:","text":"<ul> <li>Directly use monotonic.monotonic.</li> <li>Use BLATHER level for previously INFO/DEBUG statements.</li> </ul>"},{"location":"CHANGELOG/#010","title":"[0.10]:","text":"<ul> <li>Add LICENSE in generated source tarballs</li> <li>Add a version.py file that can be used to extract the current version.</li> </ul>"},{"location":"CHANGELOG/#09","title":"[0.9]:","text":"<ul> <li>Allow providing a non-standard (eventlet or other condition class) to the      r/w lock for cases where it is useful to do so.</li> <li>Instead of having the r/w lock take a find eventlet keyword argument, allow      for it to be provided a function that will be later called to get the      current thread. This allows for the current hack to be easily removed     by users (if they so desire).</li> </ul>"},{"location":"CHANGELOG/#08","title":"[0.8]:","text":"<ul> <li>Add fastener logo (from openclipart).</li> <li>Ensure r/w writer -&gt; reader -&gt; writer lock acquisition.</li> <li>Attempt to use the monotonic pypi module if its installed for monotonically      increasing time on python versions where this is not built-in.</li> </ul>"},{"location":"CHANGELOG/#07","title":"[0.7]:","text":"<ul> <li>Add helpful <code>locked</code> decorator that can lock a method using a found      attribute (a lock object or list of lock objects) in the instance the method      is attached to.</li> <li>Expose top level <code>try_lock</code> function.</li> </ul>"},{"location":"CHANGELOG/#06","title":"[0.6]:","text":"<ul> <li>Allow the sleep function to be provided (so that various alternatives other      than time.sleep can be used), ie eventlet.sleep (or other).</li> <li>Remove dependency on oslo.utils (replace with small utility code that      achieves the same effect).</li> </ul>"},{"location":"CHANGELOG/#05","title":"[0.5]:","text":"<ul> <li>Make it possible to provide an acquisition timeout to the interprocess lock      (which when acquisition can not complete in the desired time will return     false).</li> </ul>"},{"location":"CHANGELOG/#04","title":"[0.4]:","text":"<ul> <li>Have the interprocess lock acquire take a blocking keyword argument      (defaulting to true) that can avoid blocking trying to acquire the lock</li> </ul>"},{"location":"CHANGELOG/#03","title":"[0.3]:","text":"<ul> <li>Renamed from 'shared_lock' to 'fasteners'</li> </ul>"},{"location":"CHANGELOG/#021","title":"[0.2.1]","text":"<ul> <li>Fix delay not working as expected</li> </ul>"},{"location":"CHANGELOG/#02","title":"[0.2]:","text":"<ul> <li>Add a interprocess lock</li> </ul>"},{"location":"CHANGELOG/#01","title":"[0.1]:","text":"<ul> <li>Add travis yaml file</li> <li>Initial commit/import</li> </ul>"},{"location":"api/inter_process/","title":"Process Lock API","text":"<p>An interprocess lock.</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>class InterProcessLock:\n\"\"\"An interprocess lock.\"\"\"\nMAX_DELAY = 0.1  # For backwards compatibility\nDELAY_INCREMENT = 0.01  # For backwards compatibility\ndef __init__(self,\npath: Union[Path, str],\nsleep_func: Callable[[float], None] = time.sleep,\nlogger: Optional[logging.Logger] = None):\n\"\"\"\n        args:\n            path:\n                Path to the file that will be used for locking.\n            sleep_func:\n                Optional function to use for sleeping.\n            logger:\n                Optional logger to use for logging.\n        \"\"\"\nself.lockfile = None\nself.path = _utils.canonicalize_path(path)\nself.acquired = False\nself.sleep_func = sleep_func\nself.logger = _utils.pick_first_not_none(logger, LOG)\ndef _try_acquire(self, blocking, watch):\ntry:\nself.trylock()\nexcept IOError as e:\nif e.errno in (errno.EACCES, errno.EAGAIN):\nif not blocking or watch.expired():\nreturn False\nelse:\nraise _utils.RetryAgain()\nelse:\nraise threading.ThreadError(\"Unable to acquire lock on\"\n\" `%(path)s` due to\"\n\" %(exception)s\" %\n{\n'path': self.path,\n'exception': e,\n})\nelse:\nreturn True\ndef _do_open(self):\nbasedir = os.path.dirname(self.path)\nif basedir:\nmade_basedir = _ensure_tree(basedir)\nif made_basedir:\nself.logger.log(_utils.BLATHER,\n'Created lock base path `%s`', basedir)\n# Open in append mode so we don't overwrite any potential contents of\n# the target file. This eliminates the possibility of an attacker\n# creating a symlink to an important file in our lock path.\nif self.lockfile is None or self.lockfile.closed:\nself.lockfile = open(self.path, 'a')\ndef acquire(self,\nblocking: bool = True,\ndelay: float = 0.01,\nmax_delay: float = 0.1,\ntimeout: Optional[float] = None) -&gt; bool:\n\"\"\"Attempt to acquire the lock.\n        Args:\n            blocking:\n                Whether to wait to try to acquire the lock.\n            delay:\n                When `blocking`, starting delay as well as the delay increment\n                (in seconds).\n            max_delay:\n                When `blocking` the maximum delay in between attempts to\n                acquire (in seconds).\n            timeout:\n                When `blocking`, maximal waiting time (in seconds).\n        Returns:\n            whether or not the acquisition succeeded\n        \"\"\"\nif delay &lt; 0:\nraise ValueError(\"Delay must be greater than or equal to zero\")\nif timeout is not None and timeout &lt; 0:\nraise ValueError(\"Timeout must be greater than or equal to zero\")\nif delay &gt;= max_delay:\nmax_delay = delay\nself._do_open()\nwatch = _utils.StopWatch(duration=timeout)\nr = _utils.Retry(delay, max_delay,\nsleep_func=self.sleep_func, watch=watch)\nwith watch:\ngotten = r(self._try_acquire, blocking, watch)\nif not gotten:\nreturn False\nelse:\nself.acquired = True\nself.logger.log(_utils.BLATHER,\n\"Acquired file lock `%s` after waiting %0.3fs [%s\"\n\" attempts were required]\", self.path,\nwatch.elapsed(), r.attempts)\nreturn True\ndef _do_close(self):\nif self.lockfile is not None:\nself.lockfile.close()\nself.lockfile = None\ndef __enter__(self):\ngotten = self.acquire()\nif not gotten:\n# This shouldn't happen, but just in case...\nraise threading.ThreadError(\"Unable to acquire a file lock\"\n\" on `%s` (when used as a\"\n\" context manager)\" % self.path)\nreturn self\ndef release(self):\n\"\"\"Release the previously acquired lock.\"\"\"\nif not self.acquired:\nraise threading.ThreadError(\"Unable to release an unaquired lock\")\ntry:\nself.unlock()\nexcept Exception as e:\nmsg = \"Could not unlock the acquired lock opened on `%s`\", self.path\nself.logger.exception(msg)\nraise threading.ThreadError(msg) from e\nelse:\nself.acquired = False\ntry:\nself._do_close()\nexcept IOError:\nself.logger.exception(\"Could not close the file handle\"\n\" opened on `%s`\", self.path)\nelse:\nself.logger.log(_utils.BLATHER,\n\"Unlocked and closed file lock open on\"\n\" `%s`\", self.path)\ndef __exit__(self, exc_type, exc_val, exc_tb):\nself.release()\ndef exists(self):\nreturn os.path.exists(self.path)\ndef trylock(self):\n_interprocess_mechanism.trylock(self.lockfile)\ndef unlock(self):\n_interprocess_mechanism.unlock(self.lockfile)\n</code></pre> <p>An interprocess readers writer lock.</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>class InterProcessReaderWriterLock:\n\"\"\"An interprocess readers writer lock.\"\"\"\nMAX_DELAY = 0.1  # for backwards compatibility\nDELAY_INCREMENT = 0.01  # for backwards compatibility\ndef __init__(self,\npath: Union[Path, str],\nsleep_func: Callable[[float], None] = time.sleep,\nlogger: Optional[logging.Logger] = None):\n\"\"\"\n        Args:\n            path:\n                Path to the file that will be used for locking.\n            sleep_func:\n                Optional function to use for sleeping.\n            logger:\n                Optional logger to use for logging.\n        \"\"\"\nself.lockfile = None\nself.path = _utils.canonicalize_path(path)\nself.sleep_func = sleep_func\nself.logger = _utils.pick_first_not_none(logger, LOG)\n@contextmanager\ndef read_lock(self, delay=0.01, max_delay=0.1):\n\"\"\"Context manager that grans a read lock\"\"\"\nself.acquire_read_lock(blocking=True, delay=delay,\nmax_delay=max_delay, timeout=None)\ntry:\nyield\nfinally:\nself.release_read_lock()\n@contextmanager\ndef write_lock(self, delay=0.01, max_delay=0.1):\n\"\"\"Context manager that grans a write lock\"\"\"\ngotten = self.acquire_write_lock(blocking=True, delay=delay,\nmax_delay=max_delay, timeout=None)\nif not gotten:\n# This shouldn't happen, but just in case...\nraise threading.ThreadError(\"Unable to acquire a file lock\"\n\" on `%s` (when used as a\"\n\" context manager)\" % self.path)\ntry:\nyield\nfinally:\nself.release_write_lock()\ndef _try_acquire(self, blocking, watch, exclusive):\ntry:\ngotten = _interprocess_reader_writer_mechanism.trylock(self.lockfile, exclusive)\nexcept Exception as e:\nraise threading.ThreadError(\n\"Unable to acquire lock on {} due to {}!\".format(self.path, e))\nif gotten:\nreturn True\nif not blocking or watch.expired():\nreturn False\nraise _utils.RetryAgain()\ndef _do_open(self):\nbasedir = os.path.dirname(self.path)\nif basedir:\nmade_basedir = _ensure_tree(basedir)\nif made_basedir:\nself.logger.log(_utils.BLATHER,\n'Created lock base path `%s`', basedir)\nif self.lockfile is None:\nself.lockfile = _interprocess_reader_writer_mechanism.get_handle(self.path)\ndef acquire_read_lock(self,\nblocking: bool = True,\ndelay: float = 0.01,\nmax_delay: float = 0.1,\ntimeout: float = None) -&gt; bool:\n\"\"\"Attempt to acquire a reader's lock.\n        Args:\n            blocking:\n                Whether to wait to try to acquire the lock.\n            delay:\n                When `blocking`, starting delay as well as the delay increment\n                (in seconds).\n            max_delay:\n                When `blocking` the maximum delay in between attempts to\n                acquire (in seconds).\n            timeout:\n                When `blocking`, maximal waiting time (in seconds).\n        Returns:\n            whether or not the acquisition succeeded\n        \"\"\"\nreturn self._acquire(blocking, delay, max_delay, timeout, exclusive=False)\ndef acquire_write_lock(self,\nblocking: bool = True,\ndelay: float = 0.01,\nmax_delay: float = 0.1,\ntimeout: float = None) -&gt; bool:\n\"\"\"Attempt to acquire a writer's lock.\n        Args:\n            blocking:\n                Whether to wait to try to acquire the lock.\n            delay:\n                When `blocking`, starting delay as well as the delay increment\n                (in seconds).\n            max_delay:\n                When `blocking` the maximum delay in between attempts to\n                acquire (in seconds).\n            timeout:\n                When `blocking`, maximal waiting time (in seconds).\n        Returns:\n            whether or not the acquisition succeeded\n        \"\"\"\nreturn self._acquire(blocking, delay, max_delay, timeout, exclusive=True)\ndef _acquire(self, blocking=True,\ndelay=0.01, max_delay=0.1,\ntimeout=None, exclusive=True):\nif delay &lt; 0:\nraise ValueError(\"Delay must be greater than or equal to zero\")\nif timeout is not None and timeout &lt; 0:\nraise ValueError(\"Timeout must be greater than or equal to zero\")\nif delay &gt;= max_delay:\nmax_delay = delay\nself._do_open()\nwatch = _utils.StopWatch(duration=timeout)\nr = _utils.Retry(delay, max_delay,\nsleep_func=self.sleep_func, watch=watch)\nwith watch:\ngotten = r(self._try_acquire, blocking, watch, exclusive)\nif not gotten:\nreturn False\nelse:\nself.logger.log(_utils.BLATHER,\n\"Acquired file lock `%s` after waiting %0.3fs [%s\"\n\" attempts were required]\", self.path,\nwatch.elapsed(), r.attempts)\nreturn True\ndef _do_close(self):\nif self.lockfile is not None:\n_interprocess_reader_writer_mechanism.close_handle(self.lockfile)\nself.lockfile = None\ndef release_write_lock(self):\n\"\"\"Release the writer's lock.\"\"\"\ntry:\n_interprocess_reader_writer_mechanism.unlock(self.lockfile)\nexcept IOError:\nself.logger.exception(\"Could not unlock the acquired lock opened\"\n\" on `%s`\", self.path)\nelse:\ntry:\nself._do_close()\nexcept IOError:\nself.logger.exception(\"Could not close the file handle\"\n\" opened on `%s`\", self.path)\nelse:\nself.logger.log(_utils.BLATHER,\n\"Unlocked and closed file lock open on\"\n\" `%s`\", self.path)\ndef release_read_lock(self):\n\"\"\"Release the reader's lock.\"\"\"\ntry:\n_interprocess_reader_writer_mechanism.unlock(self.lockfile)\nexcept IOError:\nself.logger.exception(\"Could not unlock the acquired lock opened\"\n\" on `%s`\", self.path)\nelse:\ntry:\nself._do_close()\nexcept IOError:\nself.logger.exception(\"Could not close the file handle\"\n\" opened on `%s`\", self.path)\nelse:\nself.logger.log(_utils.BLATHER,\n\"Unlocked and closed file lock open on\"\n\" `%s`\", self.path)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.__init__","title":"<code>__init__(path, sleep_func=time.sleep, logger=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file that will be used for locking.</p> required <code>sleep_func</code> <code>Callable[[float], None]</code> <p>Optional function to use for sleeping.</p> <code>sleep</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger to use for logging.</p> <code>None</code> Source code in <code>fasteners/process_lock.py</code> <pre><code>def __init__(self,\npath: Union[Path, str],\nsleep_func: Callable[[float], None] = time.sleep,\nlogger: Optional[logging.Logger] = None):\n\"\"\"\n    args:\n        path:\n            Path to the file that will be used for locking.\n        sleep_func:\n            Optional function to use for sleeping.\n        logger:\n            Optional logger to use for logging.\n    \"\"\"\nself.lockfile = None\nself.path = _utils.canonicalize_path(path)\nself.acquired = False\nself.sleep_func = sleep_func\nself.logger = _utils.pick_first_not_none(logger, LOG)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.acquire","title":"<code>acquire(blocking=True, delay=0.01, max_delay=0.1, timeout=None)</code>","text":"<p>Attempt to acquire the lock.</p> <p>Parameters:</p> Name Type Description Default <code>blocking</code> <code>bool</code> <p>Whether to wait to try to acquire the lock.</p> <code>True</code> <code>delay</code> <code>float</code> <p>When <code>blocking</code>, starting delay as well as the delay increment (in seconds).</p> <code>0.01</code> <code>max_delay</code> <code>float</code> <p>When <code>blocking</code> the maximum delay in between attempts to acquire (in seconds).</p> <code>0.1</code> <code>timeout</code> <code>Optional[float]</code> <p>When <code>blocking</code>, maximal waiting time (in seconds).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not the acquisition succeeded</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>def acquire(self,\nblocking: bool = True,\ndelay: float = 0.01,\nmax_delay: float = 0.1,\ntimeout: Optional[float] = None) -&gt; bool:\n\"\"\"Attempt to acquire the lock.\n    Args:\n        blocking:\n            Whether to wait to try to acquire the lock.\n        delay:\n            When `blocking`, starting delay as well as the delay increment\n            (in seconds).\n        max_delay:\n            When `blocking` the maximum delay in between attempts to\n            acquire (in seconds).\n        timeout:\n            When `blocking`, maximal waiting time (in seconds).\n    Returns:\n        whether or not the acquisition succeeded\n    \"\"\"\nif delay &lt; 0:\nraise ValueError(\"Delay must be greater than or equal to zero\")\nif timeout is not None and timeout &lt; 0:\nraise ValueError(\"Timeout must be greater than or equal to zero\")\nif delay &gt;= max_delay:\nmax_delay = delay\nself._do_open()\nwatch = _utils.StopWatch(duration=timeout)\nr = _utils.Retry(delay, max_delay,\nsleep_func=self.sleep_func, watch=watch)\nwith watch:\ngotten = r(self._try_acquire, blocking, watch)\nif not gotten:\nreturn False\nelse:\nself.acquired = True\nself.logger.log(_utils.BLATHER,\n\"Acquired file lock `%s` after waiting %0.3fs [%s\"\n\" attempts were required]\", self.path,\nwatch.elapsed(), r.attempts)\nreturn True\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.release","title":"<code>release()</code>","text":"<p>Release the previously acquired lock.</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>def release(self):\n\"\"\"Release the previously acquired lock.\"\"\"\nif not self.acquired:\nraise threading.ThreadError(\"Unable to release an unaquired lock\")\ntry:\nself.unlock()\nexcept Exception as e:\nmsg = \"Could not unlock the acquired lock opened on `%s`\", self.path\nself.logger.exception(msg)\nraise threading.ThreadError(msg) from e\nelse:\nself.acquired = False\ntry:\nself._do_close()\nexcept IOError:\nself.logger.exception(\"Could not close the file handle\"\n\" opened on `%s`\", self.path)\nelse:\nself.logger.log(_utils.BLATHER,\n\"Unlocked and closed file lock open on\"\n\" `%s`\", self.path)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.__init__","title":"<code>__init__(path, sleep_func=time.sleep, logger=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file that will be used for locking.</p> required <code>sleep_func</code> <code>Callable[[float], None]</code> <p>Optional function to use for sleeping.</p> <code>sleep</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger to use for logging.</p> <code>None</code> Source code in <code>fasteners/process_lock.py</code> <pre><code>def __init__(self,\npath: Union[Path, str],\nsleep_func: Callable[[float], None] = time.sleep,\nlogger: Optional[logging.Logger] = None):\n\"\"\"\n    Args:\n        path:\n            Path to the file that will be used for locking.\n        sleep_func:\n            Optional function to use for sleeping.\n        logger:\n            Optional logger to use for logging.\n    \"\"\"\nself.lockfile = None\nself.path = _utils.canonicalize_path(path)\nself.sleep_func = sleep_func\nself.logger = _utils.pick_first_not_none(logger, LOG)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.acquire_read_lock","title":"<code>acquire_read_lock(blocking=True, delay=0.01, max_delay=0.1, timeout=None)</code>","text":"<p>Attempt to acquire a reader's lock.</p> <p>Parameters:</p> Name Type Description Default <code>blocking</code> <code>bool</code> <p>Whether to wait to try to acquire the lock.</p> <code>True</code> <code>delay</code> <code>float</code> <p>When <code>blocking</code>, starting delay as well as the delay increment (in seconds).</p> <code>0.01</code> <code>max_delay</code> <code>float</code> <p>When <code>blocking</code> the maximum delay in between attempts to acquire (in seconds).</p> <code>0.1</code> <code>timeout</code> <code>float</code> <p>When <code>blocking</code>, maximal waiting time (in seconds).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not the acquisition succeeded</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>def acquire_read_lock(self,\nblocking: bool = True,\ndelay: float = 0.01,\nmax_delay: float = 0.1,\ntimeout: float = None) -&gt; bool:\n\"\"\"Attempt to acquire a reader's lock.\n    Args:\n        blocking:\n            Whether to wait to try to acquire the lock.\n        delay:\n            When `blocking`, starting delay as well as the delay increment\n            (in seconds).\n        max_delay:\n            When `blocking` the maximum delay in between attempts to\n            acquire (in seconds).\n        timeout:\n            When `blocking`, maximal waiting time (in seconds).\n    Returns:\n        whether or not the acquisition succeeded\n    \"\"\"\nreturn self._acquire(blocking, delay, max_delay, timeout, exclusive=False)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.acquire_write_lock","title":"<code>acquire_write_lock(blocking=True, delay=0.01, max_delay=0.1, timeout=None)</code>","text":"<p>Attempt to acquire a writer's lock.</p> <p>Parameters:</p> Name Type Description Default <code>blocking</code> <code>bool</code> <p>Whether to wait to try to acquire the lock.</p> <code>True</code> <code>delay</code> <code>float</code> <p>When <code>blocking</code>, starting delay as well as the delay increment (in seconds).</p> <code>0.01</code> <code>max_delay</code> <code>float</code> <p>When <code>blocking</code> the maximum delay in between attempts to acquire (in seconds).</p> <code>0.1</code> <code>timeout</code> <code>float</code> <p>When <code>blocking</code>, maximal waiting time (in seconds).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not the acquisition succeeded</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>def acquire_write_lock(self,\nblocking: bool = True,\ndelay: float = 0.01,\nmax_delay: float = 0.1,\ntimeout: float = None) -&gt; bool:\n\"\"\"Attempt to acquire a writer's lock.\n    Args:\n        blocking:\n            Whether to wait to try to acquire the lock.\n        delay:\n            When `blocking`, starting delay as well as the delay increment\n            (in seconds).\n        max_delay:\n            When `blocking` the maximum delay in between attempts to\n            acquire (in seconds).\n        timeout:\n            When `blocking`, maximal waiting time (in seconds).\n    Returns:\n        whether or not the acquisition succeeded\n    \"\"\"\nreturn self._acquire(blocking, delay, max_delay, timeout, exclusive=True)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.read_lock","title":"<code>read_lock(delay=0.01, max_delay=0.1)</code>","text":"<p>Context manager that grans a read lock</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>@contextmanager\ndef read_lock(self, delay=0.01, max_delay=0.1):\n\"\"\"Context manager that grans a read lock\"\"\"\nself.acquire_read_lock(blocking=True, delay=delay,\nmax_delay=max_delay, timeout=None)\ntry:\nyield\nfinally:\nself.release_read_lock()\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.release_read_lock","title":"<code>release_read_lock()</code>","text":"<p>Release the reader's lock.</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>def release_read_lock(self):\n\"\"\"Release the reader's lock.\"\"\"\ntry:\n_interprocess_reader_writer_mechanism.unlock(self.lockfile)\nexcept IOError:\nself.logger.exception(\"Could not unlock the acquired lock opened\"\n\" on `%s`\", self.path)\nelse:\ntry:\nself._do_close()\nexcept IOError:\nself.logger.exception(\"Could not close the file handle\"\n\" opened on `%s`\", self.path)\nelse:\nself.logger.log(_utils.BLATHER,\n\"Unlocked and closed file lock open on\"\n\" `%s`\", self.path)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.release_write_lock","title":"<code>release_write_lock()</code>","text":"<p>Release the writer's lock.</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>def release_write_lock(self):\n\"\"\"Release the writer's lock.\"\"\"\ntry:\n_interprocess_reader_writer_mechanism.unlock(self.lockfile)\nexcept IOError:\nself.logger.exception(\"Could not unlock the acquired lock opened\"\n\" on `%s`\", self.path)\nelse:\ntry:\nself._do_close()\nexcept IOError:\nself.logger.exception(\"Could not close the file handle\"\n\" opened on `%s`\", self.path)\nelse:\nself.logger.log(_utils.BLATHER,\n\"Unlocked and closed file lock open on\"\n\" `%s`\", self.path)\n</code></pre>"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.write_lock","title":"<code>write_lock(delay=0.01, max_delay=0.1)</code>","text":"<p>Context manager that grans a write lock</p> Source code in <code>fasteners/process_lock.py</code> <pre><code>@contextmanager\ndef write_lock(self, delay=0.01, max_delay=0.1):\n\"\"\"Context manager that grans a write lock\"\"\"\ngotten = self.acquire_write_lock(blocking=True, delay=delay,\nmax_delay=max_delay, timeout=None)\nif not gotten:\n# This shouldn't happen, but just in case...\nraise threading.ThreadError(\"Unable to acquire a file lock\"\n\" on `%s` (when used as a\"\n\" context manager)\" % self.path)\ntry:\nyield\nfinally:\nself.release_write_lock()\n</code></pre>"},{"location":"api/inter_process/#decorators","title":"Decorators","text":"<p>Acquires &amp; releases an interprocess lock around the call to the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file used for locking.</p> required Source code in <code>fasteners/process_lock.py</code> <pre><code>def interprocess_locked(path: Union[Path, str]):\n\"\"\"Acquires &amp; releases an interprocess lock around the call to the\n    decorated function.\n    Args:\n        path: Path to the file used for locking.\n   \"\"\"\nlock = InterProcessLock(path)\ndef decorator(f):\n@functools.wraps(f)\ndef wrapper(*args, **kwargs):\nwith lock:\nreturn f(*args, **kwargs)\nreturn wrapper\nreturn decorator\n</code></pre> <p>Acquires &amp; releases an interprocess read lock around the call into the decorated function</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file used for locking.</p> required Source code in <code>fasteners/process_lock.py</code> <pre><code>def interprocess_read_locked(path: Union[Path, str]):\n\"\"\"Acquires &amp; releases an interprocess **read** lock around the call into\n    the decorated function\n    Args:\n        path: Path to the file used for locking.\n    \"\"\"\nlock = InterProcessReaderWriterLock(path)\ndef decorator(f):\n@functools.wraps(f)\ndef wrapper(*args, **kwargs):\nwith lock.read_lock():\nreturn f(*args, **kwargs)\nreturn wrapper\nreturn decorator\n</code></pre> <p>Acquires &amp; releases an interprocess  write lock around the call into the decorated function</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Path, str]</code> <p>Path to the file used for locking.</p> required Source code in <code>fasteners/process_lock.py</code> <pre><code>def interprocess_write_locked(path: Union[Path, str]):\n\"\"\"Acquires &amp; releases an interprocess  **write** lock around the call into\n    the decorated function\n    Args:\n        path: Path to the file used for locking.\n    \"\"\"\nlock = InterProcessReaderWriterLock(path)\ndef decorator(f):\n@functools.wraps(f)\ndef wrapper(*args, **kwargs):\nwith lock.write_lock():\nreturn f(*args, **kwargs)\nreturn wrapper\nreturn decorator\n</code></pre>"},{"location":"api/inter_thread/","title":"Thread lock API","text":"<p>             Bases: <code>object</code></p> <p>An inter-thread readers writer lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>class ReaderWriterLock(object):\n\"\"\"An inter-thread readers writer lock.\"\"\"\nWRITER = 'w'  #: Writer owner type/string constant.\nREADER = 'r'  #: Reader owner type/string constant.\ndef __init__(self,\ncondition_cls=threading.Condition,\ncurrent_thread_functor=threading.current_thread):\n\"\"\"\n        Args:\n            condition_cls:\n                Optional custom `Condition` primitive used for synchronization.\n            current_thread_functor:\n                Optional function that returns the identity of the thread in case\n                threads are not properly identified by threading.current_thread\n        \"\"\"\nself._writer = None\nself._writer_entries = 0\nself._pending_writers = collections.deque()\nself._readers = {}\nself._cond = condition_cls()\nself._current_thread = current_thread_functor\n@property\ndef has_pending_writers(self) -&gt; bool:\n\"\"\"Check if there pending writers\n        Returns:\n            Whether there are pending writers.\n        \"\"\"\nreturn bool(self._pending_writers)\ndef is_writer(self, check_pending: bool = True) -&gt; bool:\n\"\"\"Check if caller is a writer (optionally pending writer).\n        Args:\n            check_pending:\n                Whether to check for pending writer status.\n        Returns:\n            Whether the caller is the active (or optionally pending) writer.\n        \"\"\"\nme = self._current_thread()\nif self._writer == me:\nreturn True\nif check_pending:\nreturn me in self._pending_writers\nelse:\nreturn False\ndef is_reader(self) -&gt; bool:\n\"\"\"Check if caller is a reader.\n        Returns:\n            Whether the caller is an active reader.\n        \"\"\"\nme = self._current_thread()\nreturn me in self._readers\n@property\ndef owner(self) -&gt; Optional[str]:\n\"\"\"Caller ownership (if any) of the lock\n        Returns:\n            `'w'` if caller is a writer, `'r'` if caller is a reader, None otherwise.\n        \"\"\"\n\"\"\"Returns whether the lock is locked by a writer or reader.\"\"\"\nif self._writer is not None:\nreturn self.WRITER\nif self._readers:\nreturn self.READER\nreturn None\ndef acquire_read_lock(self):\n\"\"\"Acquire a read lock.\n        Will wait until no active or pending writers.\n        Raises:\n            RuntimeError: if a pending writer tries to acquire a read lock.\n        \"\"\"\nme = self._current_thread()\nself._acquire_read_lock(me)\ndef release_read_lock(self):\n\"\"\"Release a read lock.\n        Raises:\n            RuntimeError: if the current thread does not own a read lock.\n        \"\"\"\nme = self._current_thread()\nself._release_read_lock(me)\ndef _acquire_read_lock(self, me):\nif me in self._pending_writers:\nraise RuntimeError(\"Writer %s can not acquire a read lock\"\n\" while waiting for the write lock\"\n% me)\nwith self._cond:\nwhile True:\n# No active writer, or we are the writer;\n# Also no pending writers;\n# we are good to become a reader.\nif self._writer is None or self._writer == me:\nif me in self._readers:\n# ok to get a lock if current thread already has one\nself._readers[me] = self._readers[me] + 1\nbreak\nelif (self._writer == me) or not self.has_pending_writers:\nself._readers[me] = 1\nbreak\n# An active or pending writer; guess we have to wait.\nself._cond.wait()\ndef _release_read_lock(self, me, raise_on_not_owned=True):\n# I am no longer a reader, remove *one* occurrence of myself.\n# If the current thread acquired two read locks, then it will\n# still have to remove that other read lock; this allows for\n# basic reentrancy to be possible.\nwith self._cond:\ntry:\nme_instances = self._readers[me]\nif me_instances &gt; 1:\nself._readers[me] = me_instances - 1\nelse:\nself._readers.pop(me)\nexcept KeyError:\nif raise_on_not_owned:\nraise RuntimeError(f\"Thread {me} does not own a read lock\")\nself._cond.notify_all()\n@contextlib.contextmanager\ndef read_lock(self):\n\"\"\"Context manager that grants a read lock.\n        Will wait until no active or pending writers.\n        Raises:\n            RuntimeError: if a pending writer tries to acquire a read lock.\n        \"\"\"\nme = self._current_thread()\nself._acquire_read_lock(me)\ntry:\nyield self\nfinally:\nself._release_read_lock(me, raise_on_not_owned=False)\ndef _acquire_write_lock(self, me):\nif self.is_reader():\nraise RuntimeError(\"Reader %s to writer privilege\"\n\" escalation not allowed\" % me)\nwith self._cond:\nself._pending_writers.append(me)\nwhile True:\n# No readers, and no active writer, am I next??\nif len(self._readers) == 0 and self._writer is None:\nif self._pending_writers[0] == me:\nself._writer = self._pending_writers.popleft()\nself._writer_entries = 1\nbreak\nself._cond.wait()\ndef _release_write_lock(self, me, raise_on_not_owned=True):\nwith self._cond:\nself._writer = None\nself._writer_entries = 0\nself._cond.notify_all()\ndef acquire_write_lock(self):\n\"\"\"Acquire a write lock.\n        Will wait until no active readers. Blocks readers after acquiring.\n        Guaranteed for locks to be processed in fair order (FIFO).\n        Raises:\n            RuntimeError: if an active reader attempts to acquire a lock.\n        \"\"\"\nme = self._current_thread()\nif self._writer == me:\nself._writer_entries += 1\nelse:\nself._acquire_write_lock(me)\ndef release_write_lock(self):\n\"\"\"Release a write lock.\n        Raises:\n            RuntimeError: if the current thread does not own a write lock.\n        \"\"\"\nme = self._current_thread()\nif self._writer == me:\nself._writer_entries -= 1\nif self._writer_entries == 0:\nself._release_write_lock(me)\nelse:\nraise RuntimeError(f\"Thread {me} does not own a write lock\")\n@contextlib.contextmanager\ndef write_lock(self):\n\"\"\"Context manager that grants a write lock.\n        Will wait until no active readers. Blocks readers after acquiring.\n        Guaranteed for locks to be processed in fair order (FIFO).\n        Raises:\n            RuntimeError: if an active reader attempts to acquire a lock.\n        \"\"\"\nme = self._current_thread()\nif self.is_writer(check_pending=False):\nself._writer_entries += 1\ntry:\nyield self\nfinally:\nself._writer_entries -= 1\nelse:\nself._acquire_write_lock(me)\ntry:\nyield self\nfinally:\nself._release_write_lock(me)\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.has_pending_writers","title":"<code>has_pending_writers: bool</code>  <code>property</code>","text":"<p>Check if there pending writers</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether there are pending writers.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.owner","title":"<code>owner: Optional[str]</code>  <code>property</code>","text":"<p>Caller ownership (if any) of the lock</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p><code>'w'</code> if caller is a writer, <code>'r'</code> if caller is a reader, None otherwise.</p>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.__init__","title":"<code>__init__(condition_cls=threading.Condition, current_thread_functor=threading.current_thread)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>condition_cls</code> <p>Optional custom <code>Condition</code> primitive used for synchronization.</p> <code>Condition</code> <code>current_thread_functor</code> <p>Optional function that returns the identity of the thread in case threads are not properly identified by threading.current_thread</p> <code>current_thread</code> Source code in <code>fasteners/lock.py</code> <pre><code>def __init__(self,\ncondition_cls=threading.Condition,\ncurrent_thread_functor=threading.current_thread):\n\"\"\"\n    Args:\n        condition_cls:\n            Optional custom `Condition` primitive used for synchronization.\n        current_thread_functor:\n            Optional function that returns the identity of the thread in case\n            threads are not properly identified by threading.current_thread\n    \"\"\"\nself._writer = None\nself._writer_entries = 0\nself._pending_writers = collections.deque()\nself._readers = {}\nself._cond = condition_cls()\nself._current_thread = current_thread_functor\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.acquire_read_lock","title":"<code>acquire_read_lock()</code>","text":"<p>Acquire a read lock.</p> <p>Will wait until no active or pending writers.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a pending writer tries to acquire a read lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>def acquire_read_lock(self):\n\"\"\"Acquire a read lock.\n    Will wait until no active or pending writers.\n    Raises:\n        RuntimeError: if a pending writer tries to acquire a read lock.\n    \"\"\"\nme = self._current_thread()\nself._acquire_read_lock(me)\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.acquire_write_lock","title":"<code>acquire_write_lock()</code>","text":"<p>Acquire a write lock.</p> <p>Will wait until no active readers. Blocks readers after acquiring.</p> <p>Guaranteed for locks to be processed in fair order (FIFO).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an active reader attempts to acquire a lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>def acquire_write_lock(self):\n\"\"\"Acquire a write lock.\n    Will wait until no active readers. Blocks readers after acquiring.\n    Guaranteed for locks to be processed in fair order (FIFO).\n    Raises:\n        RuntimeError: if an active reader attempts to acquire a lock.\n    \"\"\"\nme = self._current_thread()\nif self._writer == me:\nself._writer_entries += 1\nelse:\nself._acquire_write_lock(me)\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.is_reader","title":"<code>is_reader()</code>","text":"<p>Check if caller is a reader.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the caller is an active reader.</p> Source code in <code>fasteners/lock.py</code> <pre><code>def is_reader(self) -&gt; bool:\n\"\"\"Check if caller is a reader.\n    Returns:\n        Whether the caller is an active reader.\n    \"\"\"\nme = self._current_thread()\nreturn me in self._readers\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.is_writer","title":"<code>is_writer(check_pending=True)</code>","text":"<p>Check if caller is a writer (optionally pending writer).</p> <p>Parameters:</p> Name Type Description Default <code>check_pending</code> <code>bool</code> <p>Whether to check for pending writer status.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the caller is the active (or optionally pending) writer.</p> Source code in <code>fasteners/lock.py</code> <pre><code>def is_writer(self, check_pending: bool = True) -&gt; bool:\n\"\"\"Check if caller is a writer (optionally pending writer).\n    Args:\n        check_pending:\n            Whether to check for pending writer status.\n    Returns:\n        Whether the caller is the active (or optionally pending) writer.\n    \"\"\"\nme = self._current_thread()\nif self._writer == me:\nreturn True\nif check_pending:\nreturn me in self._pending_writers\nelse:\nreturn False\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.read_lock","title":"<code>read_lock()</code>","text":"<p>Context manager that grants a read lock.</p> <p>Will wait until no active or pending writers.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a pending writer tries to acquire a read lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>@contextlib.contextmanager\ndef read_lock(self):\n\"\"\"Context manager that grants a read lock.\n    Will wait until no active or pending writers.\n    Raises:\n        RuntimeError: if a pending writer tries to acquire a read lock.\n    \"\"\"\nme = self._current_thread()\nself._acquire_read_lock(me)\ntry:\nyield self\nfinally:\nself._release_read_lock(me, raise_on_not_owned=False)\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.release_read_lock","title":"<code>release_read_lock()</code>","text":"<p>Release a read lock.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the current thread does not own a read lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>def release_read_lock(self):\n\"\"\"Release a read lock.\n    Raises:\n        RuntimeError: if the current thread does not own a read lock.\n    \"\"\"\nme = self._current_thread()\nself._release_read_lock(me)\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.release_write_lock","title":"<code>release_write_lock()</code>","text":"<p>Release a write lock.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the current thread does not own a write lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>def release_write_lock(self):\n\"\"\"Release a write lock.\n    Raises:\n        RuntimeError: if the current thread does not own a write lock.\n    \"\"\"\nme = self._current_thread()\nif self._writer == me:\nself._writer_entries -= 1\nif self._writer_entries == 0:\nself._release_write_lock(me)\nelse:\nraise RuntimeError(f\"Thread {me} does not own a write lock\")\n</code></pre>"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.write_lock","title":"<code>write_lock()</code>","text":"<p>Context manager that grants a write lock.</p> <p>Will wait until no active readers. Blocks readers after acquiring.</p> <p>Guaranteed for locks to be processed in fair order (FIFO).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an active reader attempts to acquire a lock.</p> Source code in <code>fasteners/lock.py</code> <pre><code>@contextlib.contextmanager\ndef write_lock(self):\n\"\"\"Context manager that grants a write lock.\n    Will wait until no active readers. Blocks readers after acquiring.\n    Guaranteed for locks to be processed in fair order (FIFO).\n    Raises:\n        RuntimeError: if an active reader attempts to acquire a lock.\n    \"\"\"\nme = self._current_thread()\nif self.is_writer(check_pending=False):\nself._writer_entries += 1\ntry:\nyield self\nfinally:\nself._writer_entries -= 1\nelse:\nself._acquire_write_lock(me)\ntry:\nyield self\nfinally:\nself._release_write_lock(me)\n</code></pre>"},{"location":"guide/","title":"User Guide","text":""},{"location":"guide/#basic-exclusive-lock-usage","title":"Basic Exclusive Lock Usage","text":"<p>Exclusive Lock for independent processes has the same API as the threading.Lock for threads: <pre><code>import fasteners\nimport threading\nlock = threading.Lock()                                 # for threads\nlock = fasteners.InterProcessLock('path/to/lock.file')  # for processes\nwith lock:\n... # exclusive access\n# or alternatively    \nlock.acquire()\n... # exclusive access\nlock.release()\n</code></pre></p>"},{"location":"guide/#basic-reader-writer-lock-usage","title":"Basic Reader Writer lock usage","text":"<p>Reader Writer lock has a similar API, which is the same for threads or processes:</p> <pre><code>import fasteners\n# for threads\nrw_lock = fasteners.ReaderWriterLock()                                 \n# for processes\nrw_lock = fasteners.InterProcessReaderWriterLock('path/to/lock.file')  \nwith rw_lock.write_lock():\n... # write access\nwith rw_lock.read_lock():\n... # read access\n# or alternatively, for processes only:\nrw_lock.acquire_read_lock()\n... # read access\nrw_lock.release_read_lock()\nrw_lock.acquire_write_lock()\n... # write access\nrw_lock.release_write_lock()\n</code></pre>"},{"location":"guide/#advanced-usage","title":"Advanced usage","text":"<p>For more details and options see Process lock details and Thread lock details.</p>"},{"location":"guide/glossary/","title":"Glossary","text":"<p>To learn more about the various aspects of locks, check the wikipedia pages for locks and readers writer locks  Here we briefly mention the main notions used in the documentation.</p> <ul> <li>Lock - a mechanism that prevents two or more threads or processes from running the same code at the same time.</li> <li>Readers writer lock - a mechanism that prevents two or more threads from having write (or write and read) access,   while allowing multiple readers.</li> <li> <p>Reentrant lock - a lock that can be acquired (and then released) multiple times, as in:</p> <pre><code>with lock:\nwith lock:\n... # some code\n</code></pre> </li> <li> <p>Mandatory lock (as opposed to advisory lock) - a lock that is enforced by the operating system, rather than   by the cooperation between threads or processes</p> </li> <li>Upgradable readers writer lock - a readers writer lock that can be upgraded from reader to writer (or downgraded   from writer to reader) without losing the lock that is already held, as in: <pre><code>with rw_lock.read_lock():\n... # read access\nwith rw_lock.write_lock():\n... # write access\n... # read access\n</code></pre></li> <li>Readers writer lock preference - describes the behaviour when multiple threads or processes are waiting for   access. Some of the patterns are:<ul> <li>Reader preference - If lock is held by readers, then new readers will get immediate access. This can result   in writers waiting forever (writer starvation).</li> <li>Writer preference - If writer is waiting for a lock, then all the new readers (and writers) will be queued   after it. This can result in readers waiting forever (reader starvation).</li> <li>Phase fair - Lock that alternates between readers and writers.</li> </ul> </li> </ul>"},{"location":"guide/inter_process/","title":"Inter process locks","text":"<p>Fasteners inter-process locks are cross-platform and are released automatically if the process crashes. They are based on the platform specific locking mechanisms:</p> <ul> <li>fcntl for posix (Linux and OSX)</li> <li>LockFileEx (via pywin32) and _locking (via msvcrt) for Windows</li> </ul>"},{"location":"guide/inter_process/#difference-from-multiprocessinglock","title":"Difference from <code>multiprocessing.Lock</code>","text":"<p>Python standard library multiprocessing.Lock functions when the processes are launched by a single main process, who is responsible for managing the  synchronization. <code>fasteners</code> locks use the operating system mechanisms for  synchronization management, and hence work between processes that were launched independently.</p>"},{"location":"guide/inter_process/#timeouts","title":"Timeouts","text":"<p><code>fasteners</code> locks support timeouts, that can be used as follows:</p> <pre><code>import fasteners\nlock = fasteners.InterProcessLock('path/to/lock.file')\nlock.acquire(timeout=10)\n... # exclusive access\nlock.release()\n</code></pre> <p>Equivalently for readers writer lock:</p> <pre><code>import fasteners\nlock = fasteners.InterProcessReaderWriterLock('path/to/lock.file')\nlock.acquire_read_lock(timeout=10)\n... # exclusive access\nlock.release_read_lock()\nlock.acquire_write_lock(timeout=10)\n... # exclusive access\nlock.release_write_lock()\n</code></pre>"},{"location":"guide/inter_process/#decorators","title":"Decorators","text":"<p>For extra sugar, a function that always needs exclusive / read / write access can be decorated using one of the provided decorators. Note that they do not  expose the timeout parameter, and always block until the lock is acquired.</p> <pre><code>import fasteners\n@fasteners.interprocess_read_locked\ndef read_file():\n...\n@fasteners.interprocess_write_locked\ndef write_file():\n...\n@fasteners.interprocess_locked\ndef do_something_exclusive():\n...\n</code></pre>"},{"location":"guide/inter_process/#lack-of-features","title":"(Lack of) Features","text":"<p>The intersection of fcntl and LockFileEx features is quite small, hence you should always assume that:</p> <ul> <li> <p>Locks are advisory. They do not prevent the modification of the locked file   by other processes.</p> </li> <li> <p>Locks can be unintentionally released by simply opening and closing the file   descriptor, so lock files must be accessed only using provided abstractions.</p> </li> <li> <p>Locks are not reentrant. An attempt to acquire a lock multiple times can   result in a deadlock or a crash upon a release of the lock.</p> </li> <li> <p>Reader writer locks are not upgradeable. An attempt to get a reader's lock   while holding a writer's lock (or vice versa) can result in a deadlock or a   crash upon a release of the lock.</p> </li> <li> <p>There are no guarantees regarding usage by multiple threads in a   single process. The locks work only between processes.</p> </li> </ul>"},{"location":"guide/inter_process/#resources","title":"Resources","text":"<p>To learn more about the complications of locking on different platforms we recommend the following resources:</p> <ul> <li> <p>File locking in Linux (blog post)</p> </li> <li> <p>On the Brokenness of File Locking (blog post)</p> </li> <li> <p>Everything you never wanted to know about file locking (blog post)</p> </li> <li> <p>Record Locking (course notes)</p> </li> <li> <p>Windows NT Files -- Locking (pywin32 docs)</p> </li> <li> <p>_locking (Windows Dev Center)</p> </li> <li> <p>LockFileEx function (Windows Dev Center)</p> </li> </ul>"},{"location":"guide/inter_thread/","title":"Inter thread locks","text":"<p>Fasteners inter-thread locks were build specifically for the needs of <code>oslo.concurrency</code> project and thus have a rather peculiar API. We do not recommend using it fully, and it is hence not documented (but maintained until the end of time).</p> <p>Instead, we recommend limiting the use of fasteners inter-thread readers writer lock to the basic API:</p> <pre><code>import fasteners\n# for threads\nrw_lock = fasteners.ReaderWriterLock()\nwith rw_lock.write_lock():\n...  # write access\nwith rw_lock.read_lock():\n...  # read access\n</code></pre>"},{"location":"guide/inter_thread/#lack-of-features","title":"(Lack of) Features","text":"<p>Fasteners inter-thread readers writer lock is</p> <ul> <li> <p>not upgradeable. An attempt to get a reader's lock while holding a writer's   lock (or vice versa) will raise an exception.</p> </li> <li> <p>reentrant (!). You can acquire (and correspondingly release) the lock   multiple times.</p> </li> <li> <p>has writer preference. Readers will queue after writers and pending writers.</p> </li> </ul>"},{"location":"guide/inter_thread/#different-thread-creation-mechanisms","title":"Different thread creation mechanisms","text":"<p>If your threads are created by some other means than the standard library <code>threading</code> module, you may need to provide corresponding thread identification and synchronisation functions to the <code>ReaderWriterLock</code>.</p>"},{"location":"guide/inter_thread/#eventlet","title":"Eventlet","text":"<p>In particular, in case of <code>eventlet</code> threads, you should monkey_patch the stdlib threads with <code>eventlet.monkey_patch(tread=True)</code> and initialise the <code>ReaderWriterLock</code> as <code>ReaderWriterLock(current_thread_functor=eventlet.getcurrent)</code>.</p>"}]}