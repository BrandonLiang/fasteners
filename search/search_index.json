{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fasteners Python standard library provides an Exclusive Lock for threads and Exclusive Lock for processes spawned by multiprocessing module. fasteners provides additional three synchronization primitives: Exclusive Lock for independent processes Readers Writer Lock for independent processes Readers Writer Lock for threads Installation pip install fasteners Usage See User Guide and Reference for usage tips and examples. Similar libraries portarlocker : readers writer lock and semaphore for independent processes, exclusive lock based on redis. py-filelock : exclusive lock for independent processes. pyReaderWriterLock : inter-thread readers writer locks, optionally downgradable, with various priorities (reader, writer, fair).","title":"Home"},{"location":"#fasteners","text":"Python standard library provides an Exclusive Lock for threads and Exclusive Lock for processes spawned by multiprocessing module. fasteners provides additional three synchronization primitives: Exclusive Lock for independent processes Readers Writer Lock for independent processes Readers Writer Lock for threads","title":"Fasteners"},{"location":"#installation","text":"pip install fasteners","title":"Installation"},{"location":"#usage","text":"See User Guide and Reference for usage tips and examples.","title":"Usage"},{"location":"#similar-libraries","text":"portarlocker : readers writer lock and semaphore for independent processes, exclusive lock based on redis. py-filelock : exclusive lock for independent processes. pyReaderWriterLock : inter-thread readers writer locks, optionally downgradable, with various priorities (reader, writer, fair).","title":"Similar libraries"},{"location":"CHANGELOG/","text":"ChangeLog The format is based on Keep a Changelog [Unreleased] Reshuffle the process lock code and properly document it. Revamp the docs and switch from sphinx to mkdocs Remove difficult to use tread lock features from docs mark unused keyword argument for deprecation in 1.0 [0.17.3]: Allow writer to become a reader in thread ReaderWriter lock [0.17.2]: Remove unnecessary setuptools pin [0.17.1]: Switch to the modern python package build infrastructure [0.17]: [NEVER RELEASED] Remove support for python 3.5 and earlier, including 2.7 Add support for python 3.9 and 3.10 Fix a conflict with django lock Add __version__ and __all__ attributes Fix a failure to parse README as utf-8 Move from nosetest to pytest and cleanup testing infrastructure [0.16.3]: Fix a failure to parse README as utf-8 on python2 [0.16.2]: Fix a failure to parse README as utf-8 [0.16.1]: [YANKED] [0.16]: Move from travis and appveyor to github actions Add interprocess reader writer lock Improve README remove unused eventlet import use stdlib monotonic instead of external for python >= 3.4 [0.15]: Add testing for additional python versions Remove python 2.6 support Remove eventlet dependency and use threading.current_thread instead [0.14]: Allow providing a custom exception logger to 'locked' decorator Allow providing a custom logger to process lock class Fix issue #12 [0.13]: Fix 'ensure_tree' check on freebsd [0.12]: Use a tiny retry util helper class for performing process locking retries. [0.11]: Directly use monotonic.monotonic. Use BLATHER level for previously INFO/DEBUG statements. [0.10]: Add LICENSE in generated source tarballs Add a version.py file that can be used to extract the current version. [0.9]: Allow providing a non-standard (eventlet or other condition class) to the r/w lock for cases where it is useful to do so. Instead of having the r/w lock take a find eventlet keyword argument, allow for it to be provided a function that will be later called to get the current thread. This allows for the current hack to be easily removed by users (if they so desire). [0.8]: Add fastener logo (from openclipart). Ensure r/w writer -> reader -> writer lock acquisition. Attempt to use the monotonic pypi module if its installed for monotonically increasing time on python versions where this is not built-in. [0.7]: Add helpful locked decorator that can lock a method using a found attribute (a lock object or list of lock objects) in the instance the method is attached to. Expose top level try_lock function. [0.6]: Allow the sleep function to be provided (so that various alternatives other than time.sleep can be used), ie eventlet.sleep (or other). Remove dependency on oslo.utils (replace with small utility code that achieves the same effect). [0.5]: Make it possible to provide an acquisition timeout to the interprocess lock (which when acquisition can not complete in the desired time will return false). [0.4]: Have the interprocess lock acquire take a blocking keyword argument (defaulting to true) that can avoid blocking trying to acquire the lock [0.3]: Renamed from 'shared_lock' to 'fasteners' [0.2.1] Fix delay not working as expected [0.2]: Add a interprocess lock [0.1]: Add travis yaml file Initial commit/import","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"The format is based on Keep a Changelog","title":"ChangeLog"},{"location":"CHANGELOG/#unreleased","text":"Reshuffle the process lock code and properly document it. Revamp the docs and switch from sphinx to mkdocs Remove difficult to use tread lock features from docs mark unused keyword argument for deprecation in 1.0","title":"[Unreleased]"},{"location":"CHANGELOG/#0173","text":"Allow writer to become a reader in thread ReaderWriter lock","title":"[0.17.3]:"},{"location":"CHANGELOG/#0172","text":"Remove unnecessary setuptools pin","title":"[0.17.2]:"},{"location":"CHANGELOG/#0171","text":"Switch to the modern python package build infrastructure","title":"[0.17.1]:"},{"location":"CHANGELOG/#017-never-released","text":"Remove support for python 3.5 and earlier, including 2.7 Add support for python 3.9 and 3.10 Fix a conflict with django lock Add __version__ and __all__ attributes Fix a failure to parse README as utf-8 Move from nosetest to pytest and cleanup testing infrastructure","title":"[0.17]: [NEVER RELEASED]"},{"location":"CHANGELOG/#0163","text":"Fix a failure to parse README as utf-8 on python2","title":"[0.16.3]:"},{"location":"CHANGELOG/#0162","text":"Fix a failure to parse README as utf-8","title":"[0.16.2]:"},{"location":"CHANGELOG/#0161-yanked","text":"","title":"[0.16.1]: [YANKED]"},{"location":"CHANGELOG/#016","text":"Move from travis and appveyor to github actions Add interprocess reader writer lock Improve README remove unused eventlet import use stdlib monotonic instead of external for python >= 3.4","title":"[0.16]:"},{"location":"CHANGELOG/#015","text":"Add testing for additional python versions Remove python 2.6 support Remove eventlet dependency and use threading.current_thread instead","title":"[0.15]:"},{"location":"CHANGELOG/#014","text":"Allow providing a custom exception logger to 'locked' decorator Allow providing a custom logger to process lock class Fix issue #12","title":"[0.14]:"},{"location":"CHANGELOG/#013","text":"Fix 'ensure_tree' check on freebsd","title":"[0.13]:"},{"location":"CHANGELOG/#012","text":"Use a tiny retry util helper class for performing process locking retries.","title":"[0.12]:"},{"location":"CHANGELOG/#011","text":"Directly use monotonic.monotonic. Use BLATHER level for previously INFO/DEBUG statements.","title":"[0.11]:"},{"location":"CHANGELOG/#010","text":"Add LICENSE in generated source tarballs Add a version.py file that can be used to extract the current version.","title":"[0.10]:"},{"location":"CHANGELOG/#09","text":"Allow providing a non-standard (eventlet or other condition class) to the r/w lock for cases where it is useful to do so. Instead of having the r/w lock take a find eventlet keyword argument, allow for it to be provided a function that will be later called to get the current thread. This allows for the current hack to be easily removed by users (if they so desire).","title":"[0.9]:"},{"location":"CHANGELOG/#08","text":"Add fastener logo (from openclipart). Ensure r/w writer -> reader -> writer lock acquisition. Attempt to use the monotonic pypi module if its installed for monotonically increasing time on python versions where this is not built-in.","title":"[0.8]:"},{"location":"CHANGELOG/#07","text":"Add helpful locked decorator that can lock a method using a found attribute (a lock object or list of lock objects) in the instance the method is attached to. Expose top level try_lock function.","title":"[0.7]:"},{"location":"CHANGELOG/#06","text":"Allow the sleep function to be provided (so that various alternatives other than time.sleep can be used), ie eventlet.sleep (or other). Remove dependency on oslo.utils (replace with small utility code that achieves the same effect).","title":"[0.6]:"},{"location":"CHANGELOG/#05","text":"Make it possible to provide an acquisition timeout to the interprocess lock (which when acquisition can not complete in the desired time will return false).","title":"[0.5]:"},{"location":"CHANGELOG/#04","text":"Have the interprocess lock acquire take a blocking keyword argument (defaulting to true) that can avoid blocking trying to acquire the lock","title":"[0.4]:"},{"location":"CHANGELOG/#03","text":"Renamed from 'shared_lock' to 'fasteners'","title":"[0.3]:"},{"location":"CHANGELOG/#021","text":"Fix delay not working as expected","title":"[0.2.1]"},{"location":"CHANGELOG/#02","text":"Add a interprocess lock","title":"[0.2]:"},{"location":"CHANGELOG/#01","text":"Add travis yaml file Initial commit/import","title":"[0.1]:"},{"location":"api/inter_process/","text":"Process Lock API InterProcessLock An interprocess lock. __init__ ( self , path , sleep_func = time . sleep , logger = None ) Parameters: Name Type Description Default path Union [ Path , str ] Path to the file that will be used for locking. required sleep_func Callable [[ float ], None] Optional function to use for sleeping. time.sleep logger Optional [ logging . Logger ] Optional logger to use for logging. None acquire ( self , blocking = True , delay = 0.01 , max_delay = 0.1 , timeout = None ) Attempt to acquire the lock. Parameters: Name Type Description Default blocking bool Whether to wait to try to acquire the lock. True delay float When blocking , starting delay as well as the delay increment (in seconds). 0.01 max_delay float When blocking the maximum delay in between attempts to acquire (in seconds). 0.1 timeout Optional [ float ] When blocking , maximal waiting time (in seconds). None Returns: Type Description bool whether or not the acquisition succeeded release ( self ) Release the previously acquired lock. InterProcessReaderWriterLock An interprocess readers writer lock. __init__ ( self , path , sleep_func = time . sleep , logger = None ) Parameters: Name Type Description Default path Union [ Path , str ] Path to the file that will be used for locking. required sleep_func Callable [[ float ], None] Optional function to use for sleeping. time.sleep logger Optional [ logging . Logger ] Optional logger to use for logging. None read_lock ( self , delay = 0.01 , max_delay = 0.1 ) Context manager that grans a read lock write_lock ( self , delay = 0.01 , max_delay = 0.1 ) Context manager that grans a write lock acquire_read_lock ( self , blocking = True , delay = 0.01 , max_delay = 0.1 , timeout = None ) Attempt to acquire a reader's lock. Parameters: Name Type Description Default blocking bool Whether to wait to try to acquire the lock. True delay float When blocking , starting delay as well as the delay increment (in seconds). 0.01 max_delay float When blocking the maximum delay in between attempts to acquire (in seconds). 0.1 timeout float When blocking , maximal waiting time (in seconds). None Returns: Type Description bool whether or not the acquisition succeeded acquire_write_lock ( self , blocking = True , delay = 0.01 , max_delay = 0.1 , timeout = None ) Attempt to acquire a writer's lock. Parameters: Name Type Description Default blocking bool Whether to wait to try to acquire the lock. True delay float When blocking , starting delay as well as the delay increment (in seconds). 0.01 max_delay float When blocking the maximum delay in between attempts to acquire (in seconds). 0.1 timeout float When blocking , maximal waiting time (in seconds). None Returns: Type Description bool whether or not the acquisition succeeded release_write_lock ( self ) Release the writer's lock. release_read_lock ( self ) Release the reader's lock. Decorators interprocess_locked ( path ) Acquires & releases an interprocess lock around the call to the decorated function. Parameters: Name Type Description Default path Union [ Path , str ] Path to the file used for locking. required interprocess_read_locked ( path ) Acquires & releases an interprocess read lock around the call into the decorated function Parameters: Name Type Description Default path Union [ Path , str ] Path to the file used for locking. required interprocess_write_locked ( path ) Acquires & releases an interprocess write lock around the call into the decorated function Parameters: Name Type Description Default path Union [ Path , str ] Path to the file used for locking. required","title":"Process locks"},{"location":"api/inter_process/#process-lock-api","text":"","title":"Process Lock API"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock","text":"An interprocess lock.","title":"InterProcessLock"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.__init__","text":"Parameters: Name Type Description Default path Union [ Path , str ] Path to the file that will be used for locking. required sleep_func Callable [[ float ], None] Optional function to use for sleeping. time.sleep logger Optional [ logging . Logger ] Optional logger to use for logging. None","title":"__init__()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.acquire","text":"Attempt to acquire the lock. Parameters: Name Type Description Default blocking bool Whether to wait to try to acquire the lock. True delay float When blocking , starting delay as well as the delay increment (in seconds). 0.01 max_delay float When blocking the maximum delay in between attempts to acquire (in seconds). 0.1 timeout Optional [ float ] When blocking , maximal waiting time (in seconds). None Returns: Type Description bool whether or not the acquisition succeeded","title":"acquire()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessLock.release","text":"Release the previously acquired lock.","title":"release()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock","text":"An interprocess readers writer lock.","title":"InterProcessReaderWriterLock"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.__init__","text":"Parameters: Name Type Description Default path Union [ Path , str ] Path to the file that will be used for locking. required sleep_func Callable [[ float ], None] Optional function to use for sleeping. time.sleep logger Optional [ logging . Logger ] Optional logger to use for logging. None","title":"__init__()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.read_lock","text":"Context manager that grans a read lock","title":"read_lock()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.write_lock","text":"Context manager that grans a write lock","title":"write_lock()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.acquire_read_lock","text":"Attempt to acquire a reader's lock. Parameters: Name Type Description Default blocking bool Whether to wait to try to acquire the lock. True delay float When blocking , starting delay as well as the delay increment (in seconds). 0.01 max_delay float When blocking the maximum delay in between attempts to acquire (in seconds). 0.1 timeout float When blocking , maximal waiting time (in seconds). None Returns: Type Description bool whether or not the acquisition succeeded","title":"acquire_read_lock()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.acquire_write_lock","text":"Attempt to acquire a writer's lock. Parameters: Name Type Description Default blocking bool Whether to wait to try to acquire the lock. True delay float When blocking , starting delay as well as the delay increment (in seconds). 0.01 max_delay float When blocking the maximum delay in between attempts to acquire (in seconds). 0.1 timeout float When blocking , maximal waiting time (in seconds). None Returns: Type Description bool whether or not the acquisition succeeded","title":"acquire_write_lock()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.release_write_lock","text":"Release the writer's lock.","title":"release_write_lock()"},{"location":"api/inter_process/#fasteners.process_lock.InterProcessReaderWriterLock.release_read_lock","text":"Release the reader's lock.","title":"release_read_lock()"},{"location":"api/inter_process/#decorators","text":"","title":"Decorators"},{"location":"api/inter_process/#fasteners.process_lock.interprocess_locked","text":"Acquires & releases an interprocess lock around the call to the decorated function. Parameters: Name Type Description Default path Union [ Path , str ] Path to the file used for locking. required","title":"interprocess_locked()"},{"location":"api/inter_process/#fasteners.process_lock.interprocess_read_locked","text":"Acquires & releases an interprocess read lock around the call into the decorated function Parameters: Name Type Description Default path Union [ Path , str ] Path to the file used for locking. required","title":"interprocess_read_locked()"},{"location":"api/inter_process/#fasteners.process_lock.interprocess_write_locked","text":"Acquires & releases an interprocess write lock around the call into the decorated function Parameters: Name Type Description Default path Union [ Path , str ] Path to the file used for locking. required","title":"interprocess_write_locked()"},{"location":"api/inter_thread/","text":"Thread lock API ReaderWriterLock ( object ) An inter-thread readers writer lock. __init__ ( self , condition_cls = threading . Condition , current_thread_functor = NOT_USED ) Parameters: Name Type Description Default condition_cls Optional custom Condition primitive used for synchronization. threading.Condition current_thread_functor Not used, will be removed in 1.0. NOT_USED has_pending_writers ( self ) Check if there pending writers Returns: Type Description bool Whether there are pending writers. is_writer ( self , check_pending = True ) Check if caller is a writer (optionally pending writer). Parameters: Name Type Description Default check_pending bool Whether to check for pending writer status. True Returns: Type Description bool Whether the caller is the active (or optionally pending) writer. is_reader ( self ) Check if caller is a reader. Returns: Type Description bool Whether the caller is an active reader. owner ( self ) Caller ownership (if any) of the lock Returns: Type Description Optional [ str ] 'w' if caller is a writer, 'r' if caller is a reader, None otherwise. read_lock ( self ) Context manager that grants a read lock. Will wait until no active or pending writers. Raises: Type Description RuntimeError if a pending writer tries to acquire a read lock. write_lock ( self ) Context manager that grants a write lock. Will wait until no active readers. Blocks readers after acquiring. Guaranteed for locks to be processed in fair order (FIFO). Raises: Type Description RuntimeError if an active reader attempts to acquire a lock.","title":"Thread locks"},{"location":"api/inter_thread/#thread-lock-api","text":"","title":"Thread lock API"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock","text":"An inter-thread readers writer lock.","title":"ReaderWriterLock"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.__init__","text":"Parameters: Name Type Description Default condition_cls Optional custom Condition primitive used for synchronization. threading.Condition current_thread_functor Not used, will be removed in 1.0. NOT_USED","title":"__init__()"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.has_pending_writers","text":"Check if there pending writers Returns: Type Description bool Whether there are pending writers.","title":"has_pending_writers()"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.is_writer","text":"Check if caller is a writer (optionally pending writer). Parameters: Name Type Description Default check_pending bool Whether to check for pending writer status. True Returns: Type Description bool Whether the caller is the active (or optionally pending) writer.","title":"is_writer()"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.is_reader","text":"Check if caller is a reader. Returns: Type Description bool Whether the caller is an active reader.","title":"is_reader()"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.owner","text":"Caller ownership (if any) of the lock Returns: Type Description Optional [ str ] 'w' if caller is a writer, 'r' if caller is a reader, None otherwise.","title":"owner()"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.read_lock","text":"Context manager that grants a read lock. Will wait until no active or pending writers. Raises: Type Description RuntimeError if a pending writer tries to acquire a read lock.","title":"read_lock()"},{"location":"api/inter_thread/#fasteners.lock.ReaderWriterLock.write_lock","text":"Context manager that grants a write lock. Will wait until no active readers. Blocks readers after acquiring. Guaranteed for locks to be processed in fair order (FIFO). Raises: Type Description RuntimeError if an active reader attempts to acquire a lock.","title":"write_lock()"},{"location":"guide/","text":"User Guide Basic Exclusive Lock Usage Exclusive Lock for independent processes has the same API as the threading.Lock for threads: import fasteners import threading lock = threading . Lock () # for threads lock = fasteners . InterProcessLock ( 'path/to/lock.file' ) # for processes with lock : ... # exclusive access # or alternatively lock . acquire () ... # exclusive access lock . release () Basic Reader Writer lock usage Reader Writer lock has a similar API, which is the same for threads or processes: import fasteners # for threads rw_lock = fasteners . ReaderWriterLock () # for processes rw_lock = fasteners . InterProcessReaderWriterLock ( 'path/to/lock.file' ) with rw_lock . write_lock (): ... # write access with rw_lock . read_lock (): ... # read access # or alternatively, for processes only: rw_lock . acquire_read_lock () ... # read access rw_lock . release_read_lock () rw_lock . acquire_write_lock () ... # write access rw_lock . release_write_lock () Advanced usage For more details and options see Process lock details and Thread lock details .","title":"User Guide"},{"location":"guide/#user-guide","text":"","title":"User Guide"},{"location":"guide/#basic-exclusive-lock-usage","text":"Exclusive Lock for independent processes has the same API as the threading.Lock for threads: import fasteners import threading lock = threading . Lock () # for threads lock = fasteners . InterProcessLock ( 'path/to/lock.file' ) # for processes with lock : ... # exclusive access # or alternatively lock . acquire () ... # exclusive access lock . release ()","title":"Basic Exclusive Lock Usage"},{"location":"guide/#basic-reader-writer-lock-usage","text":"Reader Writer lock has a similar API, which is the same for threads or processes: import fasteners # for threads rw_lock = fasteners . ReaderWriterLock () # for processes rw_lock = fasteners . InterProcessReaderWriterLock ( 'path/to/lock.file' ) with rw_lock . write_lock (): ... # write access with rw_lock . read_lock (): ... # read access # or alternatively, for processes only: rw_lock . acquire_read_lock () ... # read access rw_lock . release_read_lock () rw_lock . acquire_write_lock () ... # write access rw_lock . release_write_lock ()","title":"Basic Reader Writer lock usage"},{"location":"guide/#advanced-usage","text":"For more details and options see Process lock details and Thread lock details .","title":"Advanced usage"},{"location":"guide/glossary/","text":"Glossary To learn more about the various aspects of locks, check the wikipedia pages for locks and readers writer locks Here we briefly mention the main notions used in the documentation. Lock - a mechanism that prevents two or more threads or processes from running the same code at the same time. Readers writer lock - a mechanism that prevents two or more threads from having write (or write and read) access, while allowing multiple readers. Reentrant lock - a lock that can be acquired (and then released) multiple times, as in: with lock : with lock : ... # some code Mandatory lock (as opposed to advisory lock) - a lock that is enforced by the operating system, rather than by the cooperation between threads or processes Upgradable readers writer lock - a readers writer lock that can be upgraded from reader to writer (or downgraded from writer to reader) without losing the lock that is already held, as in: with rw_lock . read_lock (): ... # read access with rw_lock . write_lock (): ... # write access ... # read access Readers writer lock preference - describes the behaviour when multiple threads or processes are waiting for access. Some of the patterns are: Reader preference - If lock is held by readers, then new readers will get immediate access. This can result in writers waiting forever (writer starvation). Writer preference - If writer is waiting for a lock, then all the new readers (and writers) will be queued after it. This can result in readers waiting forever (reader starvation). Phase fair - Lock that alternates between readers and writers.","title":"Glossary"},{"location":"guide/glossary/#glossary","text":"To learn more about the various aspects of locks, check the wikipedia pages for locks and readers writer locks Here we briefly mention the main notions used in the documentation. Lock - a mechanism that prevents two or more threads or processes from running the same code at the same time. Readers writer lock - a mechanism that prevents two or more threads from having write (or write and read) access, while allowing multiple readers. Reentrant lock - a lock that can be acquired (and then released) multiple times, as in: with lock : with lock : ... # some code Mandatory lock (as opposed to advisory lock) - a lock that is enforced by the operating system, rather than by the cooperation between threads or processes Upgradable readers writer lock - a readers writer lock that can be upgraded from reader to writer (or downgraded from writer to reader) without losing the lock that is already held, as in: with rw_lock . read_lock (): ... # read access with rw_lock . write_lock (): ... # write access ... # read access Readers writer lock preference - describes the behaviour when multiple threads or processes are waiting for access. Some of the patterns are: Reader preference - If lock is held by readers, then new readers will get immediate access. This can result in writers waiting forever (writer starvation). Writer preference - If writer is waiting for a lock, then all the new readers (and writers) will be queued after it. This can result in readers waiting forever (reader starvation). Phase fair - Lock that alternates between readers and writers.","title":"Glossary"},{"location":"guide/inter_process/","text":"Inter process locks Fasteners inter-process locks are cross-platform and are released automatically if the process crashes. They are based on the platform specific locking mechanisms: fcntl for posix (Linux and OSX) LockFileEx (via pywin32) and _locking (via msvcrt) for Windows Difference from multiprocessing.Lock Python standard library multiprocessing.Lock functions when the processes are launched by a single main process, who is responsible for managing the synchronization. fasteners locks use the operating system mechanisms for synchronization management, and hence work between processes that were launched independently. Timeouts fasteners locks support timeouts, that can be used as follows: import fasteners lock = fasteners . InterProcessLock ( 'path/to/lock.file' ) lock . acquire ( timeout = 10 ) ... # exclusive access lock . release () Equivalently for readers writer lock: import fasteners lock = fasteners . InterProcessReaderWriterLock ( 'path/to/lock.file' ) lock . acquire_read_lock ( timeout = 10 ) ... # exclusive access lock . release_read_lock () lock . acquire_write_lock ( timeout = 10 ) ... # exclusive access lock . release_write_lock () Decorators For extra sugar, a function that always needs exclusive / read / write access can be decorated using one of the provided decorators. Note that they do not expose the timeout parameter, and always block until the lock is acquired. import fasteners @fasteners . interprocess_read_locked def read_file (): ... @fasteners . interprocess_write_locked def write_file (): ... @fasteners . interprocess_locked def do_something_exclusive (): ... (Lack of) Features The intersection of fcntl and LockFileEx features is quite small, hence you should always assume that: Locks are advisory. They do not prevent the modification of the locked file by other processes. Locks can be unintentionally released by simply opening and closing the file descriptor, so lock files must be accessed only using provided abstractions. Locks are not reentrant . An attempt to acquire a lock multiple times can result in a deadlock or a crash upon a release of the lock. Reader writer locks are not upgradeable . An attempt to get a reader's lock while holding a writer's lock (or vice versa) can result in a deadlock or a crash upon a release of the lock. There are no guarantees regarding usage by multiple threads in a single process. The locks work only between processes. Resources To learn more about the complications of locking on different platforms we recommend the following resources: File locking in Linux (blog post) On the Brokenness of File Locking (blog post) Everything you never wanted to know about file locking (blog post) Record Locking (course notes) Windows NT Files -- Locking (pywin32 docs) _locking (Windows Dev Center) LockFileEx function (Windows Dev Center)","title":"Process locks"},{"location":"guide/inter_process/#inter-process-locks","text":"Fasteners inter-process locks are cross-platform and are released automatically if the process crashes. They are based on the platform specific locking mechanisms: fcntl for posix (Linux and OSX) LockFileEx (via pywin32) and _locking (via msvcrt) for Windows","title":"Inter process locks"},{"location":"guide/inter_process/#difference-from-multiprocessinglock","text":"Python standard library multiprocessing.Lock functions when the processes are launched by a single main process, who is responsible for managing the synchronization. fasteners locks use the operating system mechanisms for synchronization management, and hence work between processes that were launched independently.","title":"Difference from multiprocessing.Lock"},{"location":"guide/inter_process/#timeouts","text":"fasteners locks support timeouts, that can be used as follows: import fasteners lock = fasteners . InterProcessLock ( 'path/to/lock.file' ) lock . acquire ( timeout = 10 ) ... # exclusive access lock . release () Equivalently for readers writer lock: import fasteners lock = fasteners . InterProcessReaderWriterLock ( 'path/to/lock.file' ) lock . acquire_read_lock ( timeout = 10 ) ... # exclusive access lock . release_read_lock () lock . acquire_write_lock ( timeout = 10 ) ... # exclusive access lock . release_write_lock ()","title":"Timeouts"},{"location":"guide/inter_process/#decorators","text":"For extra sugar, a function that always needs exclusive / read / write access can be decorated using one of the provided decorators. Note that they do not expose the timeout parameter, and always block until the lock is acquired. import fasteners @fasteners . interprocess_read_locked def read_file (): ... @fasteners . interprocess_write_locked def write_file (): ... @fasteners . interprocess_locked def do_something_exclusive (): ...","title":"Decorators"},{"location":"guide/inter_process/#lack-of-features","text":"The intersection of fcntl and LockFileEx features is quite small, hence you should always assume that: Locks are advisory. They do not prevent the modification of the locked file by other processes. Locks can be unintentionally released by simply opening and closing the file descriptor, so lock files must be accessed only using provided abstractions. Locks are not reentrant . An attempt to acquire a lock multiple times can result in a deadlock or a crash upon a release of the lock. Reader writer locks are not upgradeable . An attempt to get a reader's lock while holding a writer's lock (or vice versa) can result in a deadlock or a crash upon a release of the lock. There are no guarantees regarding usage by multiple threads in a single process. The locks work only between processes.","title":"(Lack of) Features"},{"location":"guide/inter_process/#resources","text":"To learn more about the complications of locking on different platforms we recommend the following resources: File locking in Linux (blog post) On the Brokenness of File Locking (blog post) Everything you never wanted to know about file locking (blog post) Record Locking (course notes) Windows NT Files -- Locking (pywin32 docs) _locking (Windows Dev Center) LockFileEx function (Windows Dev Center)","title":"Resources"},{"location":"guide/inter_thread/","text":"Inter thread locks Fasteners inter-thread locks were build specifically for the needs of oslo.concurrency project and thus have a rather peculiar API. We do not recommend using it fully, and it is hence not documented (but maintained until the end of time). Instead, we recommend limiting the use of fasteners inter-thread readers writer lock to the basic API: import fasteners # for threads rw_lock = fasteners . ReaderWriterLock () with rw_lock . write_lock (): ... # write access with rw_lock . read_lock (): ... # read access (Lack of) Features Fasteners inter-thread readers writer lock is not upgradeable . An attempt to get a reader's lock while holding a writer's lock (or vice versa) will raise an exception. reentrant (!). You can acquire (and correspondingly release) the lock multiple times. has writer preference. Readers will queue after writers and pending writers.","title":"Thread locks"},{"location":"guide/inter_thread/#inter-thread-locks","text":"Fasteners inter-thread locks were build specifically for the needs of oslo.concurrency project and thus have a rather peculiar API. We do not recommend using it fully, and it is hence not documented (but maintained until the end of time). Instead, we recommend limiting the use of fasteners inter-thread readers writer lock to the basic API: import fasteners # for threads rw_lock = fasteners . ReaderWriterLock () with rw_lock . write_lock (): ... # write access with rw_lock . read_lock (): ... # read access","title":"Inter thread locks"},{"location":"guide/inter_thread/#lack-of-features","text":"Fasteners inter-thread readers writer lock is not upgradeable . An attempt to get a reader's lock while holding a writer's lock (or vice versa) will raise an exception. reentrant (!). You can acquire (and correspondingly release) the lock multiple times. has writer preference. Readers will queue after writers and pending writers.","title":"(Lack of) Features"}]}